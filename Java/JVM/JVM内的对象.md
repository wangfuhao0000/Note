# 运行时的内存区域

### 1. 程序计数器

**线程私有**，可看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，包括分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖它完成。

### 2. Java虚拟机栈

**线程私有**，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时创建一个**栈帧**用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。

局部变量表存放了编译器可知的各种基本数据类型、对象应用（reference类型）和returnAddress类型，基本单位是**局部变量空间（slot）**。局部变量表所需内存空间在编译期间完成分配，所以进入一个方法时，这个方法需要在帧中分配多大的slot是完全确定的，运行时不会改变。

### 3. 本地方法栈

和Java虚拟机栈类似，只是本地方法栈为虚拟机使用到的Native方法服务，而Java虚拟机栈为执行Java方法（字节码）服务。

### 4. Java堆

线程共享，虚拟机启动时创建。此内存唯一目的就是存放对象实例，几乎所有对象实例都在这里分配内存。Java堆是垃圾回收收集器管理的主要区域，还可以细分为：**新生代**和**老年代**，再细致一点有Eden空间、From Survivor空间、To Survivor空间等。从内存分配角度，Java堆中可能划分多个**线程私有的分配缓冲区（TLAB）**，这样也只是为了能更好的回收内存。

### 5. 方法区

线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。它很少进行内存回收，回收目标主要针对**常量池的回收**和**对类型的卸载**。

### 6. 方运行时常量池

它是方法区的一部分，用于存放编译期生成的各种**字面量**和**符号引用**，这部分内容在类加载后进入方法区的运行时常量池中存放。除了保存Class文件中描述的**符号引用**外，还会把翻译出来的**直接引用**也存储在运行时常量池中。

此区域具有动态性，即运行期间也可将新的常量放入池中，例如String的intern()方法。

### 7. 直接内存

JDK1.4中新加入了NIO，它是一种基于**通道**与**缓冲区**的I / O方式，可使用Native函数库直接分配堆外内存，然后通过一个存储在堆中的DirectByteBuffer对象作为这块内存的引用进行操作。

# 对象在JVM中的布局

### 1. 对象的创建

1. 遇到new指令后，先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查此引用代表的类是否已被加载、解析和初始化过，若没有则要进行相应的初始化。
2. 类加载检查完后，虚拟机为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定。分配的方式包括“**指针碰撞**”和“**空闲列表**”两种。
3. 分配内存后，需将分配到的内存空间都初始化为零值，保证对象的实例字段不赋初值就可直接使用。
4. 对对象进行必要的设置，如此对象属于哪个类、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息放在对象的**对象头**中。
5. 以上便产生了一个对象，然后执行<init>方法，执行完后一个真正可用的对象才算完全产生出来。

### 2. 对象的内存布局

对象内存中存储的布局可分为3块区域：**对象头**、**实例数据**和**对齐填充**。

#### 对象头

对象头包括两部分信息：一部分用于存储对象自身的**运行时数据**，另一部分是**类型指针**。

运行时的数据包括如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。此部分内容和对象自身定义的数据无关

类型指针即对象指向它的类元数据的指针，通过此指针来确定这个对象是属于哪个类的实例。如果对象是个Java数组，那么对象头中还必须有一块用于记录数组长度的数据，因为虚拟机无法从数组的元数据中确定数组大小，但却可以确定一个类型的大小。

#### 实例数据

这部分是对象真正存储的有效信息，即**各种类型的字段内容**。无论是从父类继承下来的，还是在子类中定义的。这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。

#### 对齐填充

因为HotSpot VM的内存管理系统要求对象起始地址必须是8字节的整数倍，即对象的大小必须是8字节的整数倍，所以需要此部分数据来进行填充。

### 3. 对象的访问定位

因为我们使用对象时，是通过栈上的reference来进行操作的，但它只是一个引用，没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置。目前主流的访问方式有使用**句柄**和**直接指针**两种

#### 句柄

使用句柄访问的话，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的**句柄地址**，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

![img](https://note.youdao.com/yws/public/resource/b4ef39bbc01d43d64e41afc9dabd4843/xmlnote/39C36184511D40A3A3C70C3A409817AD/FCD4D40C2BC24320AEEFDB19ED22E66B/6479)

#### 直接指针

使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是**对象地址**

![img](https://note.youdao.com/yws/public/resource/b4ef39bbc01d43d64e41afc9dabd4843/xmlnote/39C36184511D40A3A3C70C3A409817AD/F79610FF0DC549D18BA97A831C456190/6486)

#### 总结

两种方式各有优劣：

- 使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（例如垃圾回收时移动对象）只会改变句柄中的实例数据指针，而reference本身不需要改变
- 使用直接指针访问的最大好处就是速度快，节省了一次指针定位的时间开销

# 内存分配策略

| **Eden** | **Survivor** | **Survivor** |
| -------- | ------------ | ------------ |
|          |              |              |

### 1. 对象优先在Eden分配

大多情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

- 新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多具备朝生夕死的特性，所以Minor GC非常频繁，回收速度也比较快
- 老年代GC（Major GC / Full GC）：发生在老年代的GC，出现了Major GC通常会伴随至少一次的Minor GC。Major GC速度一般会比Minor GC慢10倍以上。

**为什么需要两个Survivor**：https://blog.csdn.net/antony9118/article/details/51425581?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1

### 2. 大对象直接进入老年代

大对象指需要大量连续内存空间的Java对象，最典型的就是很长的字符串和数组。大对象对虚拟机的内存分配来说是个坏消息（更坏的的一群“朝生夕死”的“短命大对象”）经常会因为无处安置他们而提前触发垃圾收集以获取足够的连续空间。

虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配，目的是为了避免在Eden区及两个Survivor区之间发生大量的内存复制。

### 3. 长期存活的对象将进入老年代

虚拟机为每个对象定义了一个**对象年龄计数器**，用以标识它们是存在新生代还是老年代。若对象在Eden出生并经过第一次Minor GC后仍存活，且能被Survivor容纳，则将被移动到Survivor空间中，且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度就会被晋升到老年代。对象晋升老年代的年龄阈值，可通过参数-XX:MaxTenuringThreshold设置。

### 4. 动态对象年龄判定

为更好适应不同程度的内存状况，虚拟机并不是永远地要求对象年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一般，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。

### 5. 空间分配担保

发生Minor GC前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，若成立那么Minor GC可以确保是安全的。若不成立，虚拟机查看HandlePromotionFailure设置值是否允许担保失败，若允许则会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，若大于则尝试一次Minor GC，尽管它是**有风险的**；若小于或者HandlePromotionFailure设置不允许冒险，则这时也要改为进行一次Full GC。

说一下上面为什么说是有风险的，因为一次Minor GC后不知道有多少对象能存活，所以只能取之前每次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。

