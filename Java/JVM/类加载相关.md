# 类加载时机

类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期包括：**加载、验证、准备、解析、初始化、使用**和**卸载**7个阶段。其中验证、准备、解析3个部分统称为连接，7个阶段发生顺序如下：

![img](https://note.youdao.com/yws/public/resource/b4ef39bbc01d43d64e41afc9dabd4843/xmlnote/14E42417F4FB43C0BFF925D9659FD7D5/B711AB2DDDE04F3EB38A7A844AD95EAF/8383)

加载、验证、准备、初始化和卸载这5各阶段顺序固定，必须按部就班的开始。但解析阶段不一定：在某种情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定。说它们按部就班地开始是因为这些阶段通常是互相交叉地混合式进行，即在一个阶段运行过程中调用激活另一个阶段。

对于类什么时候加载未做规定，但规定了有且只有5种情况必须立即对类进行**“初始化”**（而加载、验证、准备自然需要在此之前开始）：

1. 遇到**new**、**getstatic**、**putstatic**或**invokestatic**这4条字节码指令时，若类没有初始化则需要先初始化。对应的常见Java代码有：用new关键字实例化对象、读取或设置一个类的静态字段（不用final修饰）、调用一个类的静态方法。
2. 使用java.lang.reflect包的方法对类进行反射调用时
3. 初始化一个类发现其父类还没有初始化，需要先触发父类的初始化
4. 虚拟机启动时，用户需指定一个要执行的主类（含main()方法的那个类），先初始化这个类
5. 使用JDK1.7的动态语言时，若一个java.lang.invoke.MethodHandle实例最后解析结果是REF_getStatic、REF_pusStatic、REF_invokeStatic的方法句柄，且此方法句柄对应的类未初始化，则需先初始化

这5种场景中的行为称为对一个类进行主动引用，除此以外所有引用类的方式都不会触发初始化，称为被动引用。下面三种情况为常见的被动引用：

- 对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。
- 通过数组定义来引用类，不会触发此类的初始化，而是触发另一个名为"[Lorg.fenixsoft.classloading.SuperClass"的类的初始化，它是一个虚拟机自动生成、直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。这个类封装了数组元素的访问方法。
- 常量（**static final**）**在编译阶段会存入调用类的常量池中**，本质上并没有直接引用到定义常量的类，所以不会触发定义常量类的初始化。

而对于接口来说，他不能使用“static{}”语句块，但编译器仍会为接口生成“<clinit>()”类构造器，用于初始化接口中所定义的成员变量。接口与类真正的区别在第3种场景：一个类初始化时要求其父类全部已经初始化，但一个接口在初始化时，并不要求其父接口全部初始化，只有用到父接口时才会初始化。

# 类加载过程

介绍一下Java虚拟机中类加载的全过程，即加载、验证、准备、解析和初始化这5个阶段所执行的具体操作。

## 1. 加载

在加载阶段，虚拟机需要完成以下3件事情：

1. 通过一个类的**全限定名**来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为**方法区**的运行时数据结构
3. 在内存中生成一个代表此类的**java.lang.Class对象**，作为方法区这个类的各种数据的访问入口

相对于类加载的其他阶段，非数组类加载阶段可控性最强。此阶段可以使用系统提供的引导类加载器完成，也可以由用户自定义的类加载器完成。

而对于数组类而言情况有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。但数组类与类加载器联系仍很密切，因为数组类的元素类型最终是要靠类加载器去创建。一个数组类创建过程遵循以下规则：

- 若数组组件类型是引用类型，则递归地去加载这个组件类型，而数组也会在加载该组件类型的类加载器的类名称空间上被标识（即此数组也会与这个类加载器绑定）。
- 若数组组件类型不是引用类型，则会把数组标记为与**引导类加载器**关联。
- 数组类的可见性与它的组件类型可见性一致，若组件类型不是引用类型，则数组类可见性默认为public。

要注意加载阶段与连接阶段（如字节码文件格式验证工作）是交叉进行的，有些属于连接阶段的内容会被夹杂在加载阶段中，但这两个阶段的开始时间仍然保持着固定的先后顺序。

## 2. 验证

验证是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，不会危害虚拟机自身安全。此阶段的工作量在虚拟机的类加载子系统中占了相当大一部分。验证阶段大致上完成下面4个阶段的校验工作：**文件格式验证、元数据验证、字节码验证、符号引用验证。**

### 2.1 文件格式验证

此阶段验证字节流是否符合**Class文件格式规范**，包括：

- 是否以魔数0xCAFEBABE开头。
- 主、次版本号是否在当前虚拟机处理范围内
- 

主要目的是保证输入的字节流能正确地解析并存储于方法区内。该阶段基于二进制字节流进行，通过此验证阶段后字节流会进入内存方法区存储，所以后面的阶段全是基于方法区的存储结构进行，不会再操作字节流。

### 2.2 元数据验证

此阶段是对字节码描述的信息进行语义分析，保证其描述的信息符合**Java语言规范**的要求。如：

- 此类是否有父类
- 此类的父类是否继承了不允许被继承的类
- 若此类不是抽象类，则需要实现父类或接口中要求实现的所有方法
- 类中的字段、方法是否与父类产生矛盾

### 2.3 字节码验证

它是整个验证过程中最复杂的一个阶段，通过**数据流**和**控制流**分析，确定程序语义是否是合法的、符合逻辑的。此阶段对**类的方法体**进行校验分析，保证被校验类的方法在运行时不会危害虚拟机。如：

- 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作
- 保证跳转指令不会跳转到方法体以外的字节码指令上
- 保证方法体中的类型转换是有效的。

### 2.4 符号引用验证

最后一个阶段发生在虚拟机将符号引用转为直接引用的时候，此转化动作将在连接的第三阶段——解析阶段发生。通常需要校验下列内容：

- 符号引用中通过字符串描述的权限定名是否能找到对应的类
- 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段
- 符号引用中的类、字段、方法的访问性是否可被当前类访问。

**符号引用验证目的是确保解析动作能正常进行**。此阶段很重要但不必要，如果运行的代码已经被反复使用和验证过，则可以略过此阶段。

## 3. 准备

此阶段正式为**类变量**分配内存并设置类变量初始值阶段，这些变量所使用的内存都将在**方法区**中进行分配。首先有两点要说明：

1. 这时候进行内存分配仅包括类变量，不包括实例变量。实例变量会在对象实例化时随对象一起分配在Java堆中。
2. 这里所说的初始值“通常情况”下是数据类型的零值。而真正赋值操作是在类构造器<clint>()方法中，是在初始化阶段进行的。当然如果类字段是final修饰的，则在准备阶段直接会被初始化。

## 4. 解析

此阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。下面介绍一下这两个词语：

- **符号应用：**可以是任何形式的字面量，只要使用时无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已加载到内存中。
- **直接引用：**可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。它适合实现的内存布局相关的，同一符号引用在不同虚拟机上翻译出来的直接引用会不同。如果有了直接引用，那引用的目标必定已经在内存中存在。

虚拟机只规定了在一些字节码指令前必须对使用的符号引用进行解析，而其他情况不予考虑。所以虚拟机可根据需要来判断是否在类被加载器加载时就解析符号引用，还是在使用前解析。有两点要注意的是：

- 除了invokedynamic指令外，虚拟机可对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）避免重复解析。虚拟机要保证在同一实体内，若一个符号引用已成功解析过，则后续也一定成功；反之失败的话后续也一直失败。
- invokedynamic指令触发过解析的符号引用时，此解析结果对于其他invokedynamic指令不一定生效。因为此指令目的就是用于动态语言支持，即必须等到程序实际运行到这条指令时，解析动作才能执行。

下面介绍一下类或接口、字段、类方法、接口方法的解析动作。

### 4.1 类或接口的解析

假设当前代码所处的类为D，要把一个从未解析的符号引用N解析为一个类或接口C的直接引用，需以下3个步骤：

1. 若C不是一个数组类型，虚拟机把代表N的全限定名传给D类的类加载器去加载这个类。这个过程是个递归的，即可能会触发其他类的加载。
2. 若C是一个数组类型，且数组的元素类型为对象，则会按照第1点的规则加载数组元素类型，**然后生成一个代表此数组维度和元素的数组对象**。
3. 若上面步骤未发生异常，那么C已经成为一个有效的类或接口了，但在解析完成后还要进行符号引用验证，确认D是否具备对C的**访问权限**。

### 4.2 字段解析

要解析一个未被解析过的字段符号引用，首先将会对字段所属的类或接口的符号引用进行解析。假设解析完成后此字段所属类或接口用C表示，虚拟机按以下步骤对字段进行搜索：

1. 若C本身包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。**（找自己）**
2. 否则，若在C中实现了接口，则按照继承关系从下往上递归找各个接口和它的父接口，接口中存在着返回此字段直接引用，查找结束。**（递归从下往上找接口）**
3. 否则，按照继承关系从下往上递归搜索其父类，若找到则返回此字段直接引用。**（找父类）**
4. 否则查找失败，抛出NoSuchFieldError异常。

若查找成功后返回了引用，会对此字段进行**权限验证**。

### 4.3 类方法解析

第一个步骤也是需要先解析出类方法所在的类，依然用C表示。后续步骤如下：

1. 类方法和接口方法符号引用的常量类型定义是分开的，若在类方法表中发现class_index中索引的C是个接口，则抛出异常
2. 若通过了第1步，在类C中查找是否有**简单名称**和**描述符**都与目标相匹配的方法，有则返回此方法引用，查找结束。
3. 否则在类C的父类中递归查找是否有相匹配的方法，若有则返回方法引用，查找结束。
4. 否则在类C实现的接口列表及它们的父接口中递归查找是否有相匹配的方法，存在说明类C是个抽象类，这时查找结束并抛出异常AbstractMethodError。因为在接口中找到说明类C并没有实现此方法，因而是个抽象类。
5. 否则宣告方法查找失败，抛出NoSuchMethodError异常。

最后若查找过程中成功返回了直接引用，将对这个方法进行**权限验证**。

### 4.4 接口方法解析

接口方法也需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，若解析成功依然用C表示此接口，接下来按如下步骤搜索接口方法：

1. 与类方法解析相反，若在接口方法表中发现class_index中的索引C是个类而不是接口，抛出异常
2. 否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，若有则返回此方法直接引用，查找结束。
3. 否则，在接口C的父接口中递归查找，直到java.lang.Object类为止，看是否有相匹配的方法，若有返回此方法直接引用，查找结束。
4. 否则，宣告方法查找失败，抛出NoSuchMethoderror异常。

由于接口中的所有方法默认都是public的，所以不存在访问权限问题。

## 5. 初始化

它是类加载过程的最后一步，此阶段才开始真正执行类中定义的Java程序代码。此阶段根据程序员通过程序制定的助管计划去初始化类变量和其他资源，即执行类构造器<clinit>()方法的过程。

- <clinit>()方法由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生。编译器收集的顺序由语句在源文件中出现的顺序决定，所以静态语句块只能访问定义在它前面的变量。
- <clinit>()方法与类的构造函数（或者说实力构造器<init>()）不同，它不需要显式地调用父类构造器，因为虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()已执行完。因此在虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object。
- 由于父类的<clinit>()方法限制性，意味着父类中定义的静态语句块要优先于子类的变量赋值操作
- <clinit>()方法对于类或接口来说并不是必需的，若一个类中没有静态语句块，也没有对变量的赋值操作，则编译器可以不为此类生成<clinit>()方法
- 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clint>()方法。但接口与类不同的是，执行接口的<clint>()方法不需要先执行父接口的<clint>()方法，只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clint>()方法。
- 虚拟机会保证一个类的<clint>()方法在**多线程环境**中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个现成去执行这个类的<clint>()方法，其他线程都需要阻塞等待，直到活动线程执行<clint>()方法完毕。如果在一个类的<clint>()方法中有耗时很长的操作，就可能造成多个进程阻塞。

# 类加载器

“类加载器”要做的就是通过一个类的全限定名来获取描述此类的二进制字节流，它是在Java虚拟机外部实现的

### 1. 类与类加载器

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每个类加载器都拥有一个独立的类名称空间。所以比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。

### 2. 双亲委派模型

从Java虚拟机角度讲，只有两种不同的类加载器：

- **启动类加载器**（BootStrap ClassLoader），它使用C++语言实现，是虚拟机自身的一部分
- 所有其他的类加载器，均是由Java语言实现，独立于虚拟机外部且全部继承于抽象类java.lang.ClassLoader。

从Java开发人员角度讲，类加载器还可以划分的更加细致，分为以下三种：

- **启动类加载器**：**它负责将存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，且是虚拟机识别的（仅按照文件名识别）类库加载到虚拟机内存中。此加载器无法被Java程序直接引用**，用户若想要把加载请求委派给引导类加载器，可直接使用null代替
- **扩展类加载器**：它负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可直接使用此加载器。
- **应用程序类加载器**：**此加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以也称为系统类加载器。他负责加载**用户路径上所指定的类库，开发者可直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下是使用这个。

下图展示了类加载器的**双亲委派模型**。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系实现，而是使用组合关系。

![](https://img-blog.csdnimg.cn/20190708234103998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlYWNod2FuZw==,size_16,color_FFFFFF,t_70)

双亲委派模型的**工作过程**是：若一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把加载请求委派给父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当附加在其反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。

使用双亲委派模型来组织类加载器之间的关系，有个好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，他存放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反若没有双亲委派模型，各个类加载器自行去加载的话，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证。一个可以避免类的重复加载，另外也避免了java的核心API被篡改

双亲委派模型实现原理也很简单：先检查是否已经被加载过，若果没有加载则调用父加载器的loadClass()方法，若父类加载器为空则默认使用启动类加载器作为父类加载器。若父类加载失败，抛出ClassNotFoundException异常后，再调用自己的**findClass()**方法进行加载。