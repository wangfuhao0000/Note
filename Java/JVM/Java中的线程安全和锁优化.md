# Java与线程

## 1. 线程的实现

实现线程主要有3种方式：使用**内核线程**实现、使用**用户线程**实现、使用**用户线程加轻量级进程**混合实现。

### 1.1 使用内核线程实现

内核线程就是直接由操作系统内核支持的线程，内核通过操纵调度器对线程进行调度和切换，并负责将线程的任务映射到各个处理器上。程序一般不会直接使用内核线程，而是使用它的一种高级接口——轻量级进程。轻量级进程就是我们通常说的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才有轻量级进程。这种轻量级进程与内核线程之间**1:1**的关系成为一对一的线程模型。

由于内核线程支持，每个轻量级进程可成为一个独立的调度单位，即使有一个轻量级进程阻塞了，也不会影响整个进程继续工作，但也有一定的局限性：

1. 由于是基于内核线程实现，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用代价相对较高，需在用户态和内核态中来回切换
2. 每个轻量级进程都需要一个内核线程支持，因此轻量级进程需消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量有限。

### 1.2 使用用户线程实现

广义上讲一个线程只要不是内核线程，就可认为是用户线程。而狭义上讲用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核帮助。这种线程不需要切换到内核态，因此操作非常快且消耗低。这种进程与用户线程之间**1：N**的关系称为一对多的线程模型。

使用用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所以线程操作需用户程序自己处理。例如“阻塞如何处理”、“多处理器系统中如何将线程映射到其他处理器上”等问题。

### 1.3 使用用户线程加轻量级进程混合实现

这种模式下。既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，且可支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可使用内核提供的线程调度功能及处理器映射，且用户线程的系统调用要通过轻量级进程来完成，大大降低了整个进程被完全阻塞的风险。这种混合模式中，用户线程与轻量级进程的数量比是不定的，即为**N：M**的关系。

### 1.4 Java线程的实现

不同平台实现不一样，对于Sun JDK来说，它的Windows版与Linux版都使用一对一的线程模型实现，一条Java线程就映射到一条轻量级进程之中。

## 2. Java线程调度

线程调度是指系统为线程分配处理器使用权的过程，主要有两种，分别是**协同式线程调度**和**抢占式线程调度**。

若使用协同式调度，线程执行时间由它本身控制，线程把自己工作完成后，要主动通知系统切换另外一个线程。

- 它最大的好处是实现简单，且由于线程要把自己的事情干完后才进行线程切换，所以切换操作是已知的，不需要同步。
- 坏处是线程执行时间不可控制，若一个线程编写有问题，一直不告知系统进行线程切换，那程序会一直阻塞。

若使用抢占式调度，那每个线程将由系统来分配执行时间，线程切换不由线程本身觉得，这种方式下线程执行时间是系统可控的，不会有一个线程导致整个进程阻塞的问题，Java使用的线程调度方式就是抢占式调度。

我们不能通过线程优先级来确定线程的调度方式。

## 3. 状态转换

Java语言定义了5种线程状态：

- **新建**：创建后尚未启动的线程处于这种状态

- **运行**：Runnable包括了操作系统线程状态中的Running和Ready，也就是此时线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。

- **无限期等待**：处于此状态的线程不会被分配CPU执行时间，它们要等待其他线程显示地唤醒，以下方法会让线程陷入无限期的等待状态：

- - 未设置Timeout参数的Object.wait()方法
  - 未设置Timeout参数的Thread.join()方法
  - LockSupport.park()方法

- **限期等待**：处于此状态的线程也不会被分配CPU执行时间，但无需等待其他线程的显式唤醒，一定时间后会由系统自动唤醒。以下方法会让线程进入无限期等待状态：

- - Thread.sleep()方法
  - 设置了Timeout参数的Object.wait()方法
  - 设置了Timeout参数的Thread.join()方法
  - LockSupport。parkNanos()方法
  - LockSupport.parkUntil()方法

- **阻塞**：它与等待状态的区别是：阻塞在等待获取一个排它锁，此事件将在另一个线程放弃此锁时发生；而等待状态则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域时，线程将进入这种状态

- **结束**：已终止线程的线程状态，线程已经结束执行。

# 线程优化

**1. Java语言中的线程安全**

按照线程安全的“安全程度”由强至弱来排序，我们可将Java语言中各种操作共享的数据分为以下5类：**不可变、绝对线程安全、相对线程安全、线程兼容**和**线程对立**。

**1.1 不可变**

Java语言中，不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需再采取任何的线程安全保障措施。前面说过final关键字带来的可见性是不变的，即只要此对象被构建出来那其外部的可见状态永远也不会改变，永远也不会看到它在多个线程之中处于不一致的状态。“不可变”带来的安全行是最简单和纯粹的。

- 共享数据是个基本数据类型，那使用final修饰时能保证它的值始终不变
- 共享数据是个对象，那使用final修饰时保证引用指向的对象是不变的。例如**String类型**、**枚举类型**。

**1.2 绝对线程安全**

**在Java API中标注自己是线程安全的类**，大多都不是绝对的线程安全。例如java.util.Vector是个线程安全的容器，因为它的add()、get()和size()方法都是被synchronized修饰的，尽管效率低但确实安全。但即使方法都被修饰成同步，也不意味着调用它的时候永远不需要同步手段。

**1.3 相对线程安全**

它需要保证对这个对象单独的操作是安全的，我们在调用是不需要额外的保障措施。但对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。Java语言中，大部分线程安全类都属于这种类型，例如Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等。

**1.4 线程兼容**

它是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可安全使用。Java API中大多类都属于线程兼容的，如与Vector和Hashtable对应的ArrayList和HashMap等。

**1.5 线程对立**

它是指调用端无论是否采用了同步措施，都无法在多线程环境中并发使用同步手段来保证对象在并发环境中可安全使用。

例如Thread类的suspend()和resume()方法，若有两个线程同时持有一个线程对象，一个尝试去中断，另一个尝试去恢复，并发执行则无论调用时是否进行了同步，目标线程都存在死锁风险。

**2. 线程安全的实现方法**

**2.1 互斥同步**

同步是指多个线程并发访问共享数据时，保证共享数据在同一个时刻只能被一个（或者是一些）线程使用。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。因此互斥是因，同步是果；互斥是方法，同步是目的。

Java中最基本的互斥同步手段就是synchronized关键字，它在编译后会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。

- 若synchronized明确指定了对象参数，那就是此对象的reference
- 若未指定，则根据它修饰的是实例方法还是类方法，去取对应的对象实例或Class对象作为锁对象

在执行monitorenter指令时，首先尝试获取对象的锁，若此对象未被锁定或当前线程已经拥有了此对象的锁，把锁的计数器加1；相应地执行monitorexit指令时会将锁计数器减1，当计数器为0是释放锁。若获取对象锁失败，那当前线程就要阻塞等待。要注意两点：

- synchronized同步块对同一条线程来说是**可重入的**，不会出现自己把自己锁死的问题。
- 同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入

**要知道Java线程是映射到操作系统的原生线程上的，若要阻塞或唤醒一个线程都需要操作系统来帮忙完成，因此需要从用户态转换到核心态，消耗更长时间**。所以它是一个重量级锁，而虚拟机会对此进行一些优化，如在操作系统阻塞之前加入一段自旋等待过程；避免频繁地切入到核心态中。

ReentrantLock能完成和synchronized类似的功能，但它增加了一些高级功能，主要有：**等待可中断**、**可实现公平锁**、**锁可以绑定多个条件**。

- **等待可中断：指当持有锁的线程长期不释放锁时，正在等待的线程可选择放弃等待改为处理其他事情**，可中断性对处理执行时间非常长的同步块很有帮助。
- **公平锁：指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获取锁；而非公平锁不保证这一点，锁释放时任何一个等待锁的线程都有机会获得锁**。synchronized中的锁是非公平的，而ReentrantLock默认也是非公平的。
- **锁绑定多个条件：指一个ReentrantLock对象可同时绑定多个Condition对象**，而在synchronized中，锁对象的wait()和notify()或nitifyAll()方法可实现一个隐含条件，若要和多于一个的条件变量关联时，就必须额外添加一个锁，而ReentrantLock只需要多次调用newCondition()方法即可。

**2.2 非阻塞同步**

互斥同步最主要的问题是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为**阻塞同步**。从处理方式来看，互斥同步属于一种**悲观的**并发策略，总是认为只要不去做正确的同步措施（例如加锁）那就肯定会出问题，无论共享数据是否真的会出现竞争，它都要进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。

当然随着指令集发展，我们有另一个选择：基于**冲突检测**的乐观并发策略。**也就是先进性操作，若没有其他线程争用共享数据则操作成功，若有数据争用，产生冲突则采取其他的补偿措施（例如不断重试直到成功）**。这种乐观的并发策略的许多实现不需要把线程挂起，因此称为**非阻塞同步**。

常用的硬件处理器指令有：

- 测试并设置(Test-and-Set)
- 获取并增加(Fetch-and-Increment)
- 交换(Swap)
- 比较并交换(Compare-and-Swap，CAS)
- 加载链接 / 条件存储(Load-Linked/Store-Conditional，LL/SC)

前三个很早就有，说一下CAS，此指令需要3个操作数，分别是：**内存位置**（变量的内存地址，V）、**旧的预期值**（A）、**新值**（B）。CAS指令执行时，当且仅当V符合旧预期值A时 ，处理器用新值B更新V的值，否则不更新。但无论是否更新了V的值，否会返回V的旧值，上述的处理过程就是个原子操作。

Java中提供了Unsafe类来实现，但因为它不是提供给用户程序调用的类（Unsafe.getUnsafe()代码中限制只有启动类加载器Bootstrap Classloader加载的Class才能访问它），所以不采用反射手段则只能通过其他的Java API来间接使用它。要注意CAS会出现**ABA问题**，可使用版本号解决，Java中也提供了原值引用类AtomicStampedReference来解决。

**2.3 无同步方案**

保证线程安全不一定要进行同步，同步只保证共享数据争用时的正确性手段，若一个方法本身不涉及共享数据，则无需任何同步措施去保证正确性。

**可重入代码：**在代码执行的任何时刻中断它转而去执行另一段代码，返回时原来的程序不会出错。它们有一些公共特征，如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。

线程本地存储：把共享数据的可见范围限制在同一个线程内，这样无须同步也能保证线程之间不出现数据争用问题。

**3. 锁优化****（重要）**

**3.1 自旋锁与自适应自旋**

互斥同步中对性能最大的影响是阻塞的实现：挂起线程和恢复线程的操作都需要转入内核态中完成。但很多时候可能只需一小段时间就可获得锁，因此让线程不放弃处理器执行时间，让它执行一个忙循环（自旋），这就是所谓的**自旋锁**。

自旋锁不能代替阻塞，因为它本身虽然避免了线程切换的开销，但要占用处理器时间。因此若锁被占用的时间很短，自旋效果会很好；反之若锁被占用时间很长，那自旋的线程只会白白消耗处理器资源。因此自旋等待时间要有一定限度，若自旋默认次数（10次）后仍未获得锁，则使用传统的方式去挂起线程。

JDK1.6中引入了**自适应的自旋锁**。自适应意味着自旋的时间不再固定了，而是由**前一次在同一个锁上的自旋时间**和**锁的拥有者的状态**来决定。

- 若在同一个锁对象上，自旋等待刚刚成功获得锁，且持有锁的线程正在运行，则虚拟机认为此次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间。
- 若对某个锁自旋很少成功获得过，那以后要获取此锁时可能省略掉自旋过程，避免浪费处理器资源。

**3.2 锁消除**

锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步、但被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，**若判断在一段代码中，堆上的所有数据都不会逃逸除去从而被其他线程访问到，那就可以把他们当做当前堆上数据对待，认为他们是线程私有的，同步加锁无须进行。**

因为有许多同步措施不是程序员自家的，例如下面的例子：

```
public String concatString(String s1, String s2, String s3) {
    return s1 + s2 + s3;
}
```

因为String是个不可变的类，连接字符串总是生成新的String对象，所以Javac编译器会对String连接做自动优化。JDK1.5后变为StringBuilder对象的连续append()操作，但JDK1.5前是变为StringBuffer的连续append()操作，而它的每个方法上都是有synchronized修饰的。此时就会把这些锁消除掉

**3.3 锁粗化**

原则上总是推荐将同步块的作用范围限制的尽量小——只在共享数据的实际作用域中才进行同步，为了使得需要同步的操作数尽量小，若存在锁竞争，那等待锁的线程也能尽快拿到锁。

大部分原则上是对的，但若一系列连续的操作都是对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中，那即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能损耗。若虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，则会把加锁同步的范围扩展（粗化）到整个操作序列的外部。

**3.3 轻量级锁**

轻量级锁不是用来代替重量级锁，它是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。它是使用对象的对象头实现的。

轻量级锁执行过程：

1. 在代码进入同步块时，若此同步对象未被锁定（锁标志位为01），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word拷贝

2. 然后虚拟机尝试将对象的Mark Word更新为指向Lock Record的指针。

3. 1. 若此更新动作完成了，则该线程就拥有了该对象的锁，且对象Mark Word的锁标志位变为00，表示此时对象处于轻量级锁定状态
   2. 若更新失败了，虚拟机先检查对象的Mark Word是否指向当前线程的栈帧，如果是说明当前线程已拥有此对象的锁，则可以直接进入同步块继续执行，否则说明这个锁对象已被其他线程抢占，若有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。

轻量级锁的解锁过程也通过CAS操作实现，若对象的Mark Word仍指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，若替换成功整个同步过程就完成了；若替换失败，则说明还有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。

轻量级锁能提高程序同步性能的依据是：**对于绝大部分的锁，在整个同步周期内都是不存在竞争的**。

- 若没有竞争，轻量级锁使用CAS避免了使用互斥量的开销
- 若存在锁竞争，那除了互斥量开销外，还额外发生了CAS，因此会比传统的重量级锁更慢。

**3.4 偏向锁**

它的目的是消除数据在无竞争情况下的同步原语。如果说轻量级锁是在无竞争情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS都不做了。偏向锁的“偏”意思是此锁会偏向于第一个获得它的线程，若接下来该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。

当锁对象第一次被线程获取时，虚拟机会把对象头中的标志位设为“01”。即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word中，若CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。

当有另外一个线程去尝试获取此锁时，偏向模式宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定或轻量级锁定的状态。