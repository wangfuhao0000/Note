### 三、接口和抽象类的区别（重要）

接口和抽象类的概念不一样。**接口是对动作的抽象，抽象类是对根源的抽象**。抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。

总结几句话来说：

1. 抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。
2. 接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现（jdk1.8中可以使用default实现接口中的方法）
3. 接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。
4. 抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。
5. 抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果
6. 抽象类里可以没有抽象方法
7. 如果一个类里有抽象方法，那么这个类只能是抽象类
8. 抽象方法要被实现，所以不能是静态的，也不能是私有的。
9. 接口可继承接口，并可多继承接口，但类只能单根继承。

1. 抽象类 和 接口 都是用来抽象具体对象的. 但是接口的抽象级别最高
2. 抽象类可以有具体的方法和属性, 接口只能有抽象方法和不可变常量
3. 抽象类主要用来抽象类别,接口主要用来抽象功能.
4. 抽象类中，且不包含任何实现，派生类必须覆盖它们。接口中所有方法都必须是未实现的。

当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。

抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度的。

- 默认方法：抽象类可以有默认的方法实现，接口中不存在方法的实现。
- 实现方式：子类使用extends关键字来继承抽象类，如果子类不是抽象类，子类需要提供抽象类中所声明方法的实现。而接口的子类使用implements来实现接口，需要提供接口中所有声明的实现。
- 构造函数：抽象类中可以有构造函数，接口中不能。
- 和正常类区别：抽象类不能被实例化，接口则是完全不同的类型。
- 访问修饰符：抽象方法可以有public,protected和default等修饰，**接口默认是public，不能使用其他修饰符。**
- 多继承：一个子类只能继承在一个抽象类，而一个子类可以实现多个接口。
- 添加新方法：想在抽象类中添加新方法，可以提供默认的实现，因此可以不修改子类现有的代码。如果往接口中添加新方法，则子类中需要实现该方法。

**五，线程、进程相关**

1. **如何创建线程，他们有什么区别?**

1. **Thread的start()和run()方法的区别？**

start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。**当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程**。

1. **wait()和sleep()方法的区别？****（重要）**

- sleep()来自Thread类，和wait()来自Object类。调用sleep()方法的过程中，线程不会释放对象锁。而调用 wait 方法线程会释放对象锁；
- **sleep()睡眠后不出让系统资源，wait()让其他线程可以占用CPU；**
- sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒，而wait()需要配合notify()或者notifyAll()使用；

**六，JAVA集合**

关于Java中的集合体系是每个人都应该烂熟于心的，尤其是对我们经常使用的List、Set、Map的原理更该如此。

**1、集合与数组的区别？**

1. 数组是固定长度的，集合可变长度的；
2. 数组可以存储基本数据类型，也可以存储引用数据类型。集合只能存储引用数据类型；
3. 数组存储的元素必须是同一个数据类型，而集合存储的对象可以是不同数据类型；

**2、Java集合的层次关系**

如图所示，图中实线边框的是实现类，折线边框的是抽象类，点线的是接口。

![img](https://note.youdao.com/yws/public/resource/222eb81bcc53cbd8ecfff72917a55a53/xmlnote/4745D9D990F54D35B1BE16D0231484B9/4e30d6ed3b8c04b43eb8a41531cc3ff2/15303)

Collection是集合类的根接口，Java中没有提供这个接口的直接的实现类。但是却让其被继承产生了两个接口List和Set。List是一个有序、可重复的集合，提供了按索引访问的方式。Set中不能包含重复的元素。

Map是Java.util包中的另一个接口，它和Collection接口没有关系，是相互独立的，但是都属于集合类的一部分。Map包含了key-value对。Map不能包含重复的key，但是可以包含相同的value。

Iterator，所有的集合类都实现了Iterator接口，这是一个用于遍历集合中元素的接口，主要包含以下三种方法：

​    1）hasNext()是否还有下一个元素。

​    2）next()返回下一个元素。

​    3）remove()删除当前元素

**3、List、Set及Map的区别**

1）List（有序、可重复）

List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。

2）Set（无序、不能重复）

Set里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。

3）Map（键值对、键唯一、值不唯一）

Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。

**4、ArrayList和LinkedList的区别?**

ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是**双向循环链表**，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。ArrrayList查询快，增删改慢，而LinkedList增删快，却查询慢。

**5、ArrayList和Vector的区别?**

ArrayList和Vector都实现了List接口，他们都是有序集合，并且存放的元素是允许重复的。它们的底层都是通过数组来实现的，因此列表这种数据结构检索数据速度快，但增删改速度慢。

ArrayList和Vector的区别：

- 线程安全。Vector是线程安全的，而ArrayList是线程不安全的。因此在如果集合数据只有单线程访问，那么使用ArrayList可以提高效率。而如果有多线程访问你的集合数据，那么就必须要用Vector，因为要保证数据安全。
- 数据增长。ArrayList和Vector都有一个初始的容量大小，当存储进它们里面的元素超过了容量时，就需要增加它们的存储容量。ArrayList每次增长原来的0.5倍，而Vector增长原来的一倍。ArrayList和Vector都可以设置初始空间的大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。

**6、LinkedHashMap及TreeMap**

LinkedHashMap保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。

TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。不允许key值为空，非同步的；

**七、异常及异常处理相关**

异常是发生在程序执行过程中阻碍程序正常执行的错误事件。比如：用户输入错误数据、硬件故障、网络阻塞等都会导致出现异常。

**1、error和exception有什么区别**

error表示系统级错误，是java运行环境内部错误或者硬件问题，不能指望程序来处理这样的问题，除退出运行外别无选择，它是Java虚拟机抛出的。

exception 表示程序需要捕捉、需要处理的异常，是由与程序设计的不完善而出现的问题，程序必须处理的问题。

![img](https://note.youdao.com/yws/public/resource/222eb81bcc53cbd8ecfff72917a55a53/xmlnote/4745D9D990F54D35B1BE16D0231484B9/d64e0b64ed1468daed8cec304888bf5c/15301)

**2、运行时异常和一般异常有何不同**

Java提供了两类主要的异常：runtimeException和checkedException

一般异常（checkedException）主要是指IO异常、SQL异常等。对于这种异常，JVM要求我们必须对其进行处理。

运行时异常（runtimeException）一般不处理，当出现这类异常时程序会由虚拟机接管。比如NullPointerException，而且这个异常也是最常见的异常之一。

出现运行时异常的时候，程序会将异常一直向上抛，一直抛到遇到处理代码，如果没有catch块进行处理，到了最上层，如果是多线程就有Thread.run()抛出，如果不是多线程那么就由main.run()抛出。抛出之后，如果是线程，那么该线程也就终止了，如果是主程序，那么该程序也就终止了。

**3、throw和throws的区别**

**throw用于主动抛出java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个 Error 或者 一个Exception，如：throw new IllegalArgumentException(“size must be multiple of 2″)。**

而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。在Java 中，任何未处理的受检查异常强制在 throws 子句中声明。

**4、你平时在项目中是怎样对异常进行处理的。**

1）尽量避免出现runtimeException 。例如对于可能出现空指针的代码，带使用对象之前一定要判断一下该对象是否为空，必要的时候对runtimeException也进行try catch处理。

2）进行try catch处理的时候要在catch代码块中对异常信息进行记录，通过调用异常类的相关方法获取到异常的相关信息，返回到web端，不仅要给用户良好的用户体验，也要能帮助程序员良好的定位异常出现的位置及原因。

3）使用自定义异常，在业务代码中将可预测的异常使用自定义异常抛出，最后通过AOP在最外层统一捕获，并根据异常类型封装返回。

**八、Spring框架**

Spring 是个java企业级应用的开源轻量级开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。

**1、Spring框架的主要功能及好处？**

**控制反转**：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。

**面向切面的编程(AOP)**：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。

**容器**：Spring 包含并管理应用中对象的生命周期和配置。

**MVC框架**：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。

**事务管理**：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。

**异常处理**：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。

**2、谈谈你对Spring IOC和AOP的理解**

**IOC即控制反转**。就是对象的创建权反转交给Spring，由容器控制程序之间的依赖关系，作用是实现了程序的解耦合，而非传统实现中，由程序代码直接操控。最直观的表达就是，IOC让对象的创建不用去new了，可以由spring自动生产，这里用的就是java的反射机制，通过反射在运行时动态的去创建、调用对象。spring就是根据配置文件在运行时动态的去创建对象，并调用对象的方法的。

Spring的IOC有三种注入方式 ： 

- **根据属性注入，也叫set方法注入；**
- **根据构造方法进行注入；**
- **根据注解进行注入（Autowired和Resource）。**

**AOP即面向切面编程**，作为面向对象的一种补充，用于解剖封装好的对象内部，找出其中对多个对象产生影响的公共行为，并将其封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），切面将那些与业务无关，却被业务模块共同调用的逻辑提取并封装起来，减少了系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理。

AOP实现的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。

1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ织入到Java字节码中，运行的时候就是增强之后的AOP对象。

2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。

Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：

​    ①JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。生成的代理对象的方法调用都会委托到InvocationHandler.invoke()方法，当我们调用代理类对象的方法时，这个“调用”会转送到invoke方法中，代理类对象作为proxy参数传入，参数method标识了我们具体调用的是代理类的哪个方法，args为这个方法的参数。

​     ②如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法，覆盖方法时可以添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。

3）静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。

**IOC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。**