# 三个线程交替打印ABC

**题目描述**

建立三个线程A、B、C，A线程打印10次字母A，B线程打印10次字母B,C线程打印10次字母C，但是要求三个线程同时运行，并且实现交替打印，即按照ABCABCABC的顺序打印。

**5种方法**

1. 使用synchronized, wait和notifyAll
2. 使用Lock->ReentrantLock 和 state标志
3. 使用Lock->ReentrantLock 和Condition（await 、signal、signalAll）
4. 使用Semaphore
5. 使用AtomicInteger

### 1、使用synchronized, wait和notifyAll

使用同步块和wait、notify的方法控制三个线程的执行次序。具体方法如下：从大的方向上来讲，该问题为三线程间的同步唤醒操作，主要的目的就是ThreadA->ThreadB->ThreadC->ThreadA循环执行三个线程。为了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以**每一个线程必须同时持有两个对象锁**，才能进行打印操作。

- 一个对象锁是`prev`，就是**前一个线程所对应的对象锁**，其主要作用是保证当前线程一定是在前一个线程操作完成后（即前一个线程释放了其对应的对象锁）才开始执行。
- 还有一个锁就是**自身对象锁**。主要的思想就是，为了控制执行的顺序，必须要先持有prev锁（也就前一个线程要释放其自身对象锁），然后当前线程再申请自己对象锁，两者兼备时打印。之后首先调用self.notify()唤醒下一个等待线程（注意notify不会立即释放对象锁，只有等到同步块代码执行完毕后才会释放），再调用prev.wait()立即释放prev对象锁，当前线程进入休眠，等待其他线程的notify操作再次唤醒。

```java
public class Synchronized_ABC {
    public static class ThreadPrinter implements Runnable {
        private String name;
      	// 两把锁：prev和self
        private Object prev;
        private Object self;

        private ThreadPrinter(String name, Object prev, Object self) {
            this.name = name;
            this.prev = prev;
            this.self = self;
        }

        @Override
        public void run() {
            int count = 10;
            while (count > 0) {
                // 多线程并发，不能用if，必须使用whil循环
                synchronized (prev) { // 先获取 prev 锁，保证前面的线程执行完了
                    synchronized (self) {// 再获取 self 锁
                        System.out.print(name);
                        count--;
                        self.notifyAll();// 唤醒其他线程竞争self锁，注意此时self锁并未立即释放。
                    }
                    // 此时执行完self的同步块，这时self锁才释放。
                    try {
                        if (count == 0) {
                            // 如果count==0,表示这是最后一次打印操作，通过notifyAll操作释放对象锁。
                            prev.notifyAll();
                        } else {
                            prev.wait(); // 立即释放 prev锁，当前线程休眠，等待唤醒
                        }
                    } catch(InterruptedException e){
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    public static void main(String[] args) throws Exception {
        Object a = new Object();
        Object b = new Object();
        Object c = new Object();
        ThreadPrinter pa = new ThreadPrinter("A", c, a);
        ThreadPrinter pb = new ThreadPrinter("B", a, b);
        ThreadPrinter pc = new ThreadPrinter("C", b, c);
        new Thread(pa).start();
        Thread.sleep(10);// 保证初始ABC的启动顺序
        new Thread(pb).start();
        Thread.sleep(10);
        new Thread(pc).start();
        Thread.sleep(10);
    }
}
```

### 2、使用Lock 和 state标志

这种思路就是让三个线程在自己内部执行10次，

1. 每次都去尝试获取锁，并判断state的值，如果符合自己的要求则打印。
2. 紧接着改变state值，则不符合自己条件了，释放锁

就这样步骤1和步骤2重复执行10次，每次都要进行这样的判断

```java
public class Lock_State_ABC {
    private static Lock lock = new ReentrantLock();
    private static int state = 0;   //通过state的值来确定是哪个线程打印

    static class ThreadPrint implements Runnable {

        int remainder = 0;  // 存储余数
        String content = "";

        public ThreadPrint(int remainder, String content) {
            this.remainder = remainder;
            this.content = content;
        }

        @Override
        public void run() {
            for(int i = 0; i < 10;) {  // 尝试获取10次锁，获取不到则等待
                try {
                    lock.lock();
                    while(state % 3 == remainder) {  //注意此处需要用while而不是if
                        System.out.println(content);
                        state++;
                        ++i;    //如果尝试成功了，则减一次
                    }
                } finally {
                    lock.unlock();
                }
            }
        }
    }

    public static void main(String[] args) throws Exception {
        new Thread(new ThreadPrint(0, "A")).start();
        //Thread.sleep(10);
        new Thread(new ThreadPrint(1, "B")).start();
        //Thread.sleep(10);
        new Thread(new ThreadPrint(2, "C")).start();
    }
}
```

### 3、使用Lock->ReentrantLock 和Condition（await 、signal、signalAll）

```java
private Lock lock = new ReentrantLock();  
private Condition condition = lock.newCondition(); 
condition.await();//this.wait();  
condition.signal();//this.notify();  
condition.signalAll();//this.notifyAll();
```

Condition是被绑定到Lock上的，必须使用`lock.newCondition()`才能创建一个Condition。从上面的代码可以看出，Synchronized能实现的通信方式，Condition都可以实现，功能类似的代码写在同一行中。这样解题思路就和第一种方法基本一致，只是采用的方法不同。

```
public class Lock_Condition_ABC {
    private static Lock lock = new ReentrantLock();
    private static Condition A = lock.newCondition();
    private static Condition B = lock.newCondition();
    private static Condition C = lock.newCondition();

    private static int count = 0;

    static class ThreadA extends Thread {
        @Override
        public void run() {
            try {
                lock.lock();

                for (int i = 0; i < 10; i++) {
                    while (count % 3 != 0){//注意这里是不等于0，也就是说没轮到该线程执行，之前一直等待状态
                        A.await(); //该线程A将会释放lock锁，构造成节点加入等待队列并进入等待状态
                    }
                    System.out.print("A");
                    count++;
                    B.signal(); // A执行完唤醒B线程
                }

            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }

    static class ThreadB extends Thread {
        @Override
        public void run() {
            try {
                lock.lock();
                for (int i = 0; i < 10; i++) {
                    while (count % 3 != 1)
                        B.await();// B释放lock锁，当前面A线程执行后会通过B.signal()唤醒该线程
                    System.out.print("B");
                    count++;
                    C.signal();// B执行完唤醒C线程
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }

    static class ThreadC extends Thread {
        @Override
        public void run() {
            try {
                lock.lock();
                for (int i = 0; i < 10; i++) {
                    while (count % 3 != 2)
                        C.await();// C释放lock锁
                    System.out.print("C");
                    count++;
                    A.signal();// C执行完唤醒A线程
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        new ThreadA().start();
        new ThreadB().start();
        new ThreadC().start();
    }
}
```

**4、使用Semaphore**

**4.1 Semaphore介绍**

Semaphore又称信号量，是操作系统中的一个概念，在Java并发编程中，信号量控制的是线程并发的数量。

————————————————————————————————————————————————

**Semaphore实现原理简单理解：**

Semaphore是用来保护一个或者多个共享资源的访问，**Semaphore信号量内部维护了一个计数器，其值为可以访问的共享资源的个数。一个线程要访问共享资源，先获得信号量，如果信号量的计数器值大于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。**

就好比一个厕所管理员，站在门口，只有厕所有空位，就开门允许与空侧数量等量的人进入厕所。多个人进入厕所后，相当于N个人来分配使用N个空位。为避免多个人来同时竞争同一个侧卫，在内部仍然使用锁来控制资源的同步访问。

如果计数器值为0,线程进入休眠。当某个线程使用完共享资源后，释放信号量，并将信号量内部的计数器加1，之前进入休眠的线程将被唤醒并再次试图获得信号量。

————————————————————————————————————————————————

Semaphore内部主要通过AQS（AbstractQueuedSynchronizer）实现线程的管理。Semaphore有两个构造函数，第一个参数permits表示许可数，它最后传递给了AQS的state值。线程在运行时首先获取许可，如果成功，许可数就减1，线程运行，当线程运行结束就释放许可，许可数就加1。如果许可数为0，则获取失败，线程位于AQS的等待队列中，它会被其它释放许可的线程唤醒。在创建Semaphore对象的时候还可以指定它的公平性。一般常用非公平的信号量，非公平信号量是指在获取许可时先尝试获取许可，而不必关心是否已有需要获取许可的线程位于等待队列中，如果获取失败，才会入列。而公平的信号量在获取许可时首先要查看等待队列中是否已有线程，如果有则入列。

```
//非公平的构造函数
public Semaphore(int permits);//permits=10，表示允许10个线程获取许可证，最大并发数是10；
////通过fair参数决定公平性
public Semaphore(int permits，boolean fair)

Semaphore semaphore = new Semaphore(10,true);  
semaphore.acquire();  //线程获取许可证
//do something here  
semaphore.release();  //线程归还许可证
```

**4.2 代码**

```
public class Semaphore_ABC {
    // 以A开始的信号量,初始信号量数量为1
    private static Semaphore A = new Semaphore(1);
    // B、C信号量,A完成后开始,初始信号数量为0
    private static Semaphore B = new Semaphore(0);
    private static Semaphore C = new Semaphore(0);

    static class ThreadA extends Thread {
        @Override
        public void run() {
            try {
                for (int i = 0; i < 10; i++) {
                    A.acquire();// A获取信号执行,A信号量减1,当A为0时将无法继续获得该信号量
                    System.out.print("A");
                    B.release();// B释放信号，B信号量加1（初始为0），此时可以获取B信号量
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    static class ThreadB extends Thread {
        @Override
        public void run() {
            try {
                for (int i = 0; i < 10; i++) {
                    B.acquire();
                    System.out.print("B");
                    C.release();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    static class ThreadC extends Thread {
        @Override
        public void run() {
            try {
                for (int i = 0; i < 10; i++) {
                    C.acquire();
                    System.out.println("C");
                    A.release();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        new ThreadA().start();
        new ThreadB().start();
        new ThreadC().start();
    }

}
```

可以看到信号量的变化情况如下：

初始(A=1,B=0,C=0)—>第一次执行线程A时(A=1,B=0,C=0)—->第一次执行线程B时（A=0,B=1,C=0）—->第一次执行线程C时(A=0,B=0,C=1)—>第二次执行线程A(A=1,B=0,C=0)如此循环。

### 5、使用AtomicInteger

相当于三个线程去不断轮询AtomicInteger变量，如果当前的变量小于阈值，且符合自己打印的条件则执行打印，并更改变量的值。要知道的时虽然三个线程都在执行轮询，但一个时间肯定是只能有一个线程打印，而我们因为原子增加且保证余数为0则打印A，所以是可以实现的。

```java
public class Atomic_ABC {
    private static AtomicInteger ai = new AtomicInteger(0);
    private static final int MAX_SYC_VALUE = 3 * 10;

    public static class RunnableA implements Runnable {
        int remainder = 0;
        String content = "";

        public RunnableA(int remainder, String content) {
            this.remainder = remainder;
            this.content = content;
        }

        @Override
        public void run() {
            while (ai.get() < MAX_SYC_VALUE) {
                if(ai.get() % 3 == remainder) {
                    System.out.println(content);
                    ai.getAndIncrement();
                }
            }
        }
    }

    public static void main(String[] args) {
        new Thread(new RunnableA(0, "A")).start();
        new Thread(new RunnableA(1, "B")).start();
        new Thread(new RunnableA(2, "C")).start();
        //当然可以使用线程池
        ExecutorService service = Executors.newFixedThreadPool(3);
        service.execute(new RunnableA(0, "A"));
        service.execute(new RunnableA(1, "B"));
        service.execute(new RunnableA(2, "C"));
        service.shutdown();
    }
}
```

# 让线程按照顺序执行

**我们下面需要完成这样一个应用场景：**

1.早上；2.测试人员、产品经理、开发人员陆续的来公司上班；3.产品经理规划新需求；4.开发人员开发新需求功能；5.测试人员测试新功能。

规划需求，开发需求新功能，测试新功能是一个有顺序的，我们把thread1看做产品经理，thread2看做开发人员，thread3看做测试人员。

### 1. 使用线程的 join 方法

**join():** 是Theard的方法，作用是调用线程需等待该`join()`线程执行完成后，才能继续用下运行。

**应用场景:** 当一个线程必须等待另一个线程执行完毕才能执行时可以使用join方法。

```java
package com.wwj.javabase.thread.order;

/**
 * @author wwj
 * 通过子程序join使线程按顺序执行
 */
public class ThreadJoinDemo {

    public static void main(String[] args) {
        final Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("产品经理规划新需求");
            }
        });

        final Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    thread1.join();  //等thread1执行完
                    System.out.println("开发人员开发新需求功能");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        Thread thread3 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    thread2.join();  //等thread2执行完
                    System.out.println("测试人员测试新功能");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        System.out.println("早上：");
        System.out.println("测试人员来上班了...");
        thread3.start();
        System.out.println("产品经理来上班了...");
        thread1.start();
        System.out.println("开发人员来上班了...");
        thread2.start();
    }
}
```

### 2. 使用主线程的 join 方法

这里是在主线程中使用`join()`来实现对线程的阻塞。

```
package com.wwj.javabase.thread.order;

/**
 * @author wwj
 * 通过主程序join使线程按顺序执行
 */
public class ThreadMainJoinDemo {

    public static void main(String[] args) throws Exception {

        final Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("产品经理正在规划新需求...");
            }
        });

        final Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("开发人员开发新需求功能");
            }
        });

        final Thread thread3 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("测试人员测试新功能");
            }
        });

        System.out.println("早上:");
        System.out.println("产品经理来上班了");
        System.out.println("测试人员来上班了");
        System.out.println("开发人员来上班了");
        thread1.start(); 
        //在父进程调用子进程的join()方法后，父进程需要等待子进程运行完再继续运行。
        System.out.println("开发人员和测试人员休息会...");
        thread1.join();  //先等thread1执行完
        System.out.println("产品经理新需求规划完成!");
        thread2.start(); 
        System.out.println("测试人员休息会...");
        thread2.join();   //再等thread2执行完
        thread3.start();  //最后执行thread3
    }
}
```

**3. 使用线程的 wait 方法**

- **wait():** 是Object的方法，作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)

- **notify()和notifyAll():** 是Object的方法，作用则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。

- **wait(long timeout):** 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的notify()方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。

**应用场景：** Java实现生产者消费者的方式。

```
package com.wwj.javabase.thread.order;

/**
 * @author wwj
 */
public class ThreadWaitDemo {

    private static Object myLock1 = new Object();
    private static Object myLock2 = new Object();

    /**
     * 为什么要加这两个标识状态?
     * 如果没有状态标识，当t1已经运行完了t2才运行，t2在等待t1唤醒导致t2永远处于等待状态
     */
    private static Boolean t1Run = false;
    private static Boolean t2Run = false;
    public static void main(String[] args) {

        final Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (myLock1){
                    System.out.println("产品经理规划新需求...");
                    t1Run = true;
                    myLock1.notify();
                }
            }
        });

        final Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (myLock1){
                    try {
                        if(!t1Run){
                            System.out.println("开发人员先休息会...");
                            myLock1.wait();
                        }
                        synchronized (myLock2){
                            System.out.println("开发人员开发新需求功能");
                            myLock2.notify();
                        }
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });

        Thread thread3 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (myLock2){
                    try {
                        if(!t2Run){
                            System.out.println("测试人员先休息会...");
                            myLock2.wait();
                        }
                        System.out.println("测试人员测试新功能");
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });

        System.out.println("早上：");
        System.out.println("测试人员来上班了...");
        thread3.start();
        System.out.println("产品经理来上班了...");
        thread1.start();
        System.out.println("开发人员来上班了...");
        thread2.start();
    }
}
```

运行结果:这里输出会有很多种顺序，主要是因为线程进入的顺序，造成锁住线程的顺序不一致。

早上：测试人员来上班了… 产品经理来上班了… 开发人员来上班了… 测试人员先休息会… 产品经理规划新需求… 开发人员开发新需求功能 测试人员测试新功能

**4. 使用线程的线程池方法**

JAVA通过Executors提供了四种线程池

- 单线程化线程池(newSingleThreadExecutor);
- 可控最大并发数线程池(newFixedThreadPool);
- 可回收缓存线程池(newCachedThreadPool);
- 支持定时与周期性任务的线程池(newScheduledThreadPool)。

**单线程化线程池(newSingleThreadExecutor):** 优点，串行执行所有任务。

**submit()：** 提交任务。

**shutdown()：** 方法用来关闭线程池，拒绝新任务。

**应用场景:** 串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。**此线程池保证所有任务的执行顺序按照任务的提交顺序执行。**

```
package com.wwj.javabase.thread.order;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author wwj
 * 通过SingleThreadExecutor让线程按顺序执行
 */
public class ThreadPoolDemo {

    static ExecutorService executorService = Executors.newSingleThreadExecutor();

    public static void main(String[] args) throws Exception {

        final Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("产品经理规划新需求");
            }
        });

        final Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("开发人员开发新需求功能");
            }
        });

        Thread thread3 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("测试人员测试新功能");
            }
        });

        System.out.println("早上：");
        System.out.println("产品经理来上班了");
        System.out.println("测试人员来上班了");
        System.out.println("开发人员来上班了");
        System.out.println("领导吩咐:");
        System.out.println("首先，产品经理规划新需求...");
        executorService.submit(thread1);
        System.out.println("然后，开发人员开发新需求功能...");
        executorService.submit(thread2);
        System.out.println("最后，测试人员测试新功能...");
        executorService.submit(thread3);
        executorService.shutdown();
    }
}
```

运行结果

早上：产品经理来上班了 测试人员来上班了 开发人员来上班了 领导吩咐: 首先，产品经理规划新需求… 然后，开发人员开发新需求功能… 最后，测试人员测试新功能… 产品经理规划新需求 开发人员开发新需求功能 测试人员测试新功能

**5. 使用线程的 Condition(条件变量) 方法**

**Condition（条件变量）:** 通常与一个锁关联。需要在多个Contidion中共享一个锁时，可以传递一个Lock/RLock实例给构造方法，否则它将自己生成一个RLock实例。

- Condition中await()方法类似于Object类中的wait()方法。
- Condition中await(long time,TimeUnit unit)方法类似于Object类中的wait(long time)方法。
- Condition中signal()方法类似于Object类中的notify()方法。
- Condition中signalAll()方法类似于Object类中的notifyAll()方法。

**应用场景：** Condition是一个多线程间协调通信的工具类，使得某个，或者某些线程一起等待某个条件（Condition）,只有当该条件具备( signal 或者 signalAll方法被调用)时 ，这些等待线程才会被唤醒，从而重新争夺锁。

```
package com.wwj.javabase.thread.order;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author wwj
 * 使用Condition(条件变量)实现线程按顺序运行
 */
public class ThreadConditionDemo {

    private static Lock lock = new ReentrantLock();
    private static Condition condition1 = lock.newCondition();
    private static Condition condition2 = lock.newCondition();

    /**
     * 为什么要加这两个标识状态?
     * 如果没有状态标识，当t1已经运行完了t2才运行，t2在等待t1唤醒导致t2永远处于等待状态
     */
    private static Boolean t1Run = false;
    private static Boolean t2Run = false;

    public static void main(String[] args) {

        final Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                lock.lock();
                System.out.println("产品经理规划新需求");
                t1Run = true;
                condition1.signal();
                lock.unlock();
            }
        });

        final Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                lock.lock();
                try {
                    if(!t1Run){
                        System.out.println("开发人员先休息会...");
                        condition1.await();
                    }
                    System.out.println("开发人员开发新需求功能");
                    t2Run = true;
                    condition2.signal();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                lock.unlock();
            }
        });

        Thread thread3 = new Thread(new Runnable() {
            @Override
            public void run() {
                lock.lock();
                try {
                    if(!t2Run){
                        System.out.println("测试人员先休息会...");
                        condition2.await();
                    }
                    System.out.println("测试人员测试新功能");
                    lock.unlock();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        System.out.println("早上：");
        System.out.println("测试人员来上班了...");
        thread3.start();
        System.out.println("产品经理来上班了...");
        thread1.start();
        System.out.println("开发人员来上班了...");
        thread2.start();
    }
}
```

运行结果:这里输出会有很多种顺序，主要是因为线程进入的顺序，造成锁住线程的顺序不一致

早上：测试人员来上班了… 产品经理来上班了… 开发人员来上班了… 测试人员先休息会… 产品经理规划新需求 开发人员开发新需求功能 测试人员测试新功能

**6. 使用线程的 CuDownLatch(倒计数) 方法**

**CountDownLatch:** 位于java.util.concurrent包下，利用它可以实现类似计数器的功能。

**应用场景:** 比如有一个任务C，它要等待其他任务A,B执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。

```
package com.wwj.javabase.thread.order;

import java.util.concurrent.CountDownLatch;

/**
 * @author wwj
 * 通过CountDownLatch（倒计数）使线程按顺序执行
 */
public class ThreadCountDownLatchDemo {

    /**
     * 用于判断线程一是否执行，倒计时设置为1，执行后减1
     */
    private static CountDownLatch c1 = new CountDownLatch(1);

    /**
     * 用于判断线程二是否执行，倒计时设置为1，执行后减1
     */
    private static CountDownLatch c2 = new CountDownLatch(1);

    public static void main(String[] args) {
        final Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("产品经理规划新需求");
                //对c1倒计时-1
                c1.countDown();
            }
        });

        final Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    //等待c1倒计时，计时为0则往下运行
                    c1.await();
                    System.out.println("开发人员开发新需求功能");
                    //对c2倒计时-1
                    c2.countDown();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        Thread thread3 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    //等待c2倒计时，计时为0则往下运行
                    c2.await();
                    System.out.println("测试人员测试新功能");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        System.out.println("早上：");
        System.out.println("测试人员来上班了...");
        thread3.start();
        System.out.println("产品经理来上班了...");
        thread1.start();
        System.out.println("开发人员来上班了...");
        thread2.start();
    }
}
```

运行结果

早上：测试人员来上班了… 产品经理来上班了… 开发人员来上班了… 产品经理规划新需求 开发人员开发新需求功能 测试人员测试新功能

**7. 使用 CyclicBarrier (回环栅栏)实现线程按顺序执行**

**CyclicBarrier(回环栅栏):** 通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。

**应用场景:** 公司组织春游,等待所有的员工到达集合地点才能出发，每个人到达后进入barrier状态。都到达后，唤起大家一起出发去旅行。

```
package com.wwj.javabase.thread.order;

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

/**
 * @author wwj
 * 使用CyclicBarrier(回环栅栏)实现线程按顺序运行
 */
public class CyclicBarrierDemo {

    static CyclicBarrier barrier1 = new CyclicBarrier(2);
    static CyclicBarrier barrier2 = new CyclicBarrier(2);

    public static void main(String[] args) {

        final Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    System.out.println("产品经理规划新需求");
                    //放开栅栏1
                    barrier1.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }
        });

        final Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    //放开栅栏1
                    barrier1.await();
                    System.out.println("开发人员开发新需求功能");
                    //放开栅栏2
                    barrier2.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }
        });

        final Thread thread3 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    //放开栅栏2
                    barrier2.await();
                    System.out.println("测试人员测试新功能");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }
        });

        System.out.println("早上：");
        System.out.println("测试人员来上班了...");
        thread3.start();
        System.out.println("产品经理来上班了...");
        thread1.start();
        System.out.println("开发人员来上班了...");
        thread2.start();
    }
}
```

运行结果

早上：测试人员来上班了… 产品经理来上班了… 开发人员来上班了… 产品经理规划新需求 开发人员开发新需求功能 测试人员测试新功能

**8. 使用线程的 Sephmore(信号量) 实现线程按顺序执行**

**Sephmore(信号量):** Semaphore是一个计数信号量,从概念上将，Semaphore包含一组许可证,如果有需要的话，每个acquire()方法都会阻塞，直到获取一个可用的许可证,每个release()方法都会释放持有许可证的线程，并且归还Semaphore一个可用的许可证。然而，实际上并没有真实的许可证对象供线程使用，Semaphore只是对可用的数量进行管理维护。

**acquire():** 当前线程尝试去阻塞的获取1个许可证,此过程是阻塞的,当前线程获取了1个可用的许可证，则会停止等待，继续执行。

**release():** 当前线程释放1个可用的许可证。

**应用场景:** Semaphore可以用来做流量分流，特别是对公共资源有限的场景，比如数据库连接。假设有这个的需求，读取几万个文件的数据到数据库中，由于文件读取是IO密集型任务，可以启动几十个线程并发读取，但是数据库连接数只有10个，这时就必须控制最多只有10个线程能够拿到数据库连接进行操作。这个时候，就可以使用Semaphore做流量控制。

```
package com.wwj.javabase.thread.order;

import java.util.concurrent.Semaphore;
/**
 * @author wwj
 * 使用Sephmore(信号量)实现线程按顺序运行
 */
public class SemaphoreDemo {
    private static Semaphore semaphore1 = new Semaphore(1);
    private static Semaphore semaphore2 = new Semaphore(1);
    public static void main(String[] args) {
        final Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("产品经理规划新需求");
                semaphore1.release();
            }
        });

        final Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    semaphore1.acquire();
                    System.out.println("开发人员开发新需求功能");
                    semaphore2.release();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        Thread thread3 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    semaphore2.acquire();
                    thread2.join();
                    semaphore2.release();
                    System.out.println("测试人员测试新功能");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        System.out.println("早上：");
        System.out.println("测试人员来上班了...");
        thread3.start();
        System.out.println("产品经理来上班了...");
        thread1.start();
        System.out.println("开发人员来上班了...");
        thread2.start();
    }
}
```

运行结果

早上：测试人员来上班了… 产品经理来上班了… 开发人员来上班了… 产品经理规划新需求 开发人员开发新需求功能 测试人员测试新功能

# 手写生产者-消费者模式

**什么是生产者和消费者模式：**

生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此并不直接通信，而是通过阻塞队列进行通信，所以生产者生产完数据后不用等待消费者进行处理，而是直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列中获取数据，阻塞队列就相当于一个缓冲区，平衡生产者和消费者的处理能力。

**wait/notify和synchronized配合实现：**

**生产者和消费者线程各一条：**

```
代码实现：
package ThreadDemo.ThreadExercise;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/*
 * 生产者线程
 */
class ProducerDemo implements Runnable{
    private List list;
    public ProducerDemo(List list){
        this.list=list;
    }
    @Override
    public void run() {
        while(true){
            Random random=new Random();
            synchronized(list){
                if(list.size()>0){ //表明集合中有元素，此线程等待
                //可以是while
                    try {
                        list.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                list.add(random.nextInt(100));//0-99的随机数；
                System.out.println(Thread.currentThread().getName()+"  "+list.get(0));
                list.notify(); //通知消费者，集合中已有元素。
            }
        }
    }
}
/*
 *  消费者线程
 */
class ConsumerDemo implements Runnable{
    private List list;
    public ConsumerDemo(List list){
         this.list=list;
    }
    @Override
    public void run() {
        while(true){
            synchronized (list){
                if(list.size()<1){//可以是while
                    try {
                        list.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println(Thread.currentThread().getName()+"  "+list.remove(0));
                list.notify();
            }
        }
    }
}
public class ProducerAndConsumer {
    public static void main(String[] args) {
        List list=new ArrayList();
        Thread thread1=new Thread(new ProducerDemo(list));
        thread1.setName("生产者线程_");
        Thread thread2=new Thread(new ConsumerDemo(list));
        thread2.setName("......消费者线程_");
        thread2.start();
        thread1.start();
    }
}
测试结果：
生产者线程_  88
......消费者线程_  88
生产者线程_  77
......消费者线程_  77
生产者线程_  49
......消费者线程_  49
生产者线程_  62
......消费者线程_  62
生产者线程_  94
......消费者线程_  94
生产者线程_  64
......消费者线程_  64
生产者线程_  33
......消费者线程_  33
生产者线程_  41
......消费者线程_  41
生产者线程_  7
......消费者线程_  7
生产者线程_  21
......消费者线程_  21

["LRUCache","put","put","get","put","get","put","get","get","get"]
[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]
```

**多条生产者和消费者线程：**

注意事项：

多条线程需要注意是：

- 我们唤醒的时候需要使用notifyAll()，如果使用notify（）随机唤醒的可能是同一类线程，这样会导致死锁；
- 需要将if改为while，比如生产者线程有多个，当本生产者线程wait之后，假如另一个生产者线程得到锁（本该消费者得到），如果是if，那么此线程就会继续执行，会导致数据错乱。如果是while则会继续等待。

代码实现：

package ThreadDemo.ThreadExercise; import java.util.ArrayList; import java.util.List; import java.util.Random; /* * 生产者线程 */ class ProducerDemo implements Runnable{    private List list;    public ProducerDemo(List list){        this.list=list;    }    @Override    public void run() {        while(true){            Random random=new Random();            synchronized(list){                while(list.size()>0){                     //因为生产者线程有多个，当本线程wait之后，假如一个生产者线程得到锁（本该消费者得到），                    // 如果是if，那么此线程就会继续执行，会导致数据错乱。                    //如果是while则会继续等待。                    try {                        list.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                list.add(random.nextInt(100));//0-99的随机数；                System.out.println(Thread.currentThread().getName()+"  "+list.get(0));                list.notifyAll();  //唤醒此对象锁所有等待线程（消费者和生产者线程均有）            }        }    } } /* *  消费者线程 */ class ConsumerDemo implements Runnable{    private List list;    public ConsumerDemo(List list){         this.list=list;    }    @Override    public void run() {        while(true){            synchronized (list){                while(list.size()<1){                    try {                        list.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                System.out.println(Thread.currentThread().getName()+"  "+list.remove(0));                list.notifyAll(); //唤醒此对象锁所有等待线程（消费者和生产者线程均有）            }        }    } } public class ProducerAndConsumer {    public static void main(String[] args) {        List list=new ArrayList();        for (int i = 1; i <4 ; i++) {            Thread thread1=new Thread(new ProducerDemo(list));            thread1.setName("生产者线程_"+i+"_");            Thread thread2=new Thread(new ConsumerDemo(list));            thread2.setName("......消费者线程_"+i+"_");            thread2.start();            thread1.start();        }    } }

测试结果：

生产者线程_3_  83 ......消费者线程_1_  83 生产者线程_1_  74 ......消费者线程_2_  74 生产者线程_3_  18 ......消费者线程_3_  18 生产者线程_1_  81 ......消费者线程_2_  81 生产者线程_3_  56 ......消费者线程_1_  56 生产者线程_1_  3 ......消费者线程_2_  3 生产者线程_3_  0 ......消费者线程_3_  0 生产者线程_1_  18 ......消费者线程_2_  18 生产者线程_3_  18 ......消费者线程_1_  18 生产者线程_1_  35 ......消费者线程_2_  35 生产者线程_3_  81 ......消费者线程_3_  81 生产者线程_1_  15 ......消费者线程_2_  15 生产者线程_3_  95 ......消费者线程_1_  95 生产者线程_1_  2 ......消费者线程_2_  2

**ReentrantLock+BlockingQueue实现：**

采用两把锁，实现生产者和消费者同时作业。需要注意的是，生产者的一个锁对象，消费者一个锁对象。分别用来唤醒消费者和生产者

**代码实现1：**

多条生产者和消费者随机交替，也就是说只要队列没有满那一直生产，只要队列没有空那就一直消费。

```
package ThreadDemo.ThreadExercise;

import java.util.Queue;
import java.util.Random;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
//生产者
class ProducerDemo1 implements Runnable{
    ReentrantLock put;  //阻塞放的
    ReentrantLock out;  //阻塞拿的
    Condition notFull;  //
    Condition notEmpty; //
    Queue<Integer> queue;
    public ProducerDemo1(ReentrantLock put,ReentrantLock out,Condition notFull,Condition notEmpty,Queue queue){
        this.put=put;
        this.out=out;
        this.notFull=notFull;
        this.notEmpty=notEmpty;
        this.queue=queue;
    }

    @Override
    public void run() {
        Random random=new Random();
        while(true){
            put.lock();  //只能自己添加元素
            while(queue.size()==10){
                try {
                    notFull.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //延迟打印速度
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            Integer integer=random.nextInt(100);
            System.out.println(Thread.currentThread().getName()+"........."+integer);
            queue.add(integer);
            //队列没有满，通知更多生产者来生产
            if(queue.size()<10){
                notFull.signal();
            }
            put.unlock();
            //只要生产出一个就通知消费者消费，后续不需要通知
            //因为消费者内部有唤醒更多消费者的机制
            if(queue.size()==1){
                out.lock();
                notEmpty.signal();
                out.unlock();
            }
        }
    }
}
class ConsumerDemo1 implements Runnable{
    ReentrantLock put;
    ReentrantLock out;
    Condition notFull;
    Condition notEmpty;
    Queue<Integer> queue;
    public ConsumerDemo1(ReentrantLock put,ReentrantLock out,Condition notFull,Condition notEmpty,Queue queue){
        this.put=put;
        this.out=out;
        this.notFull=notFull;
        this.notEmpty=notEmpty;
        this.queue=queue;
    }

    @Override
    public void run() {
        while(true){
            out.lock();
            while(queue.size()==0){
                try {
                    notEmpty.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+"   "+queue.poll());
            //只要队列里还有元素，就通知更多消费者来消费
            if(queue.size()>0){
                notEmpty.signal();
            }
            out.unlock();
            //只要队列没有满，就通知生产者进行生产
            if(queue.size()==9){
                put.lock();
                notFull.signal();
                put.unlock();
            }
        }
    }
}
public class ProducerAndConsumerDemo {
    public static void main(String[] args) {
        LinkedBlockingQueue<Integer> queue=new LinkedBlockingQueue<>();
        ReentrantLock put=new ReentrantLock();
        Condition notFull=put.newCondition();
        ReentrantLock out=new ReentrantLock();
        Condition notEmpty=out.newCondition();
        for (int i = 0; i <3 ; i++) {
            new Thread(new ProducerDemo1(put,out,notFull,notEmpty,queue),"生产者"+i).start();
            new Thread(new ConsumerDemo1(put,out,notFull,notEmpty,queue),"消费者"+i).start();
        }
    }
}
测试结果：
生产者0.........91
生产者0.........99
消费者0   91
消费者0   99
生产者1.........99
生产者1.........12
消费者1   99
生产者2.........79
消费者1   12
生产者0.........22
消费者1   79
消费者1   22
生产者1.........23
消费者1   23
生产者1.........19
生产者1.........79
消费者2   19
消费者2   79
生产者2.........39
消费者1   39
生产者0.........48
生产者0.........43
消费者0   48
生产者1.........64
消费者0   43
生产者2.........65
消费者0   64
消费者0   65
生产者0.........24
生产者0.........72
消费者0   24
生产者1.........79
消费者0   72
生产者2.........49
消费者0   79
消费者0   49
生产者0.........41
消费者0   41
生产者0.........25
消费者1   25
```

**代码实现2：**

多条生产者和消费者，实现生产满了在消费，消费完了在生产。

```
package ThreadDemo.ThreadExercise;

import java.util.Queue;
import java.util.Random;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
//生产者
class ProducerDemo1 implements Runnable{
    ReentrantLock put;
    ReentrantLock out;
    Condition notFull;
    Condition notEmpty;
    Queue<Integer> queue;
    public ProducerDemo1(ReentrantLock put,ReentrantLock out,Condition notFull,Condition notEmpty,Queue queue){
        this.put=put;
        this.out=out;
        this.notFull=notFull;
        this.notEmpty=notEmpty;
        this.queue=queue;
    }

    @Override
    public void run() {
        Random random=new Random();
        while(true){
            put.lock();
            while(queue.size()==10){
                try {
                    notFull.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //延迟打印速度
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            Integer integer=random.nextInt(100);
            System.out.println(Thread.currentThread().getName()+"........."+integer);
            queue.add(integer);
            //队列没有满，通知更多生产者来生产
            if(queue.size()<10){
                notFull.signal();
            }
            put.unlock();
            // 当队列已满时才通知消费者进行消费
            if(queue.size()==10){
                out.lock();
                notEmpty.signal();
                out.unlock();
            }
        }
    }
}
class ConsumerDemo1 implements Runnable{
    ReentrantLock put;
    ReentrantLock out;
    Condition notFull;
    Condition notEmpty;
    Queue<Integer> queue;
    public ConsumerDemo1(ReentrantLock put,ReentrantLock out,Condition notFull,Condition notEmpty,Queue queue){
        this.put=put;
        this.out=out;
        this.notFull=notFull;
        this.notEmpty=notEmpty;
        this.queue=queue;
    }

    @Override
    public void run() {
        while(true){
            out.lock();
            while(queue.size()==0){
                try {
                    notEmpty.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+"   "+queue.poll());
            //只要队列里还有元素，就通知更多消费者来消费
            if(queue.size()>0){
                notEmpty.signal();
            }
            out.unlock();
            //当队列为空时，通知生产者进行生产
            if(queue.size()==0){
                put.lock();
                notFull.signal();
                put.unlock();
            }
        }
    }
}
public class ProducerAndConsumerDemo {
    public static void main(String[] args) {
        LinkedBlockingQueue<Integer> queue=new LinkedBlockingQueue<>();
        ReentrantLock put=new ReentrantLock();
        Condition notFull=put.newCondition();
        ReentrantLock out=new ReentrantLock();
        Condition notEmpty=out.newCondition();
        for (int i = 0; i <3 ; i++) {
            new Thread(new ProducerDemo1(put,out,notFull,notEmpty,queue),"生产者"+i).start();
            new Thread(new ConsumerDemo1(put,out,notFull,notEmpty,queue),"消费者"+i).start();
        }
    }
}
测试结果
生产者0.........19
生产者0.........28
生产者0.........76
生产者1.........56
生产者1.........69
生产者1.........44
生产者1.........77
生产者1.........51
生产者1.........56
生产者1.........99
消费者0   19
消费者0   28
消费者0   76
消费者1   56
消费者1   69
消费者1   44
消费者1   77
消费者1   51
消费者1   56
消费者1   99
生产者2.........20
生产者2.........42
生产者2.........56
生产者2.........47
生产者2.........38
生产者2.........90
生产者2.........54
生产者2.........66
生产者2.........79
生产者2.........96
消费者2   20
消费者2   42
消费者2   56
消费者2   47
消费者2   38
消费者2   90
消费者2   54
消费者2   66
消费者2   79
消费者2   96
```

