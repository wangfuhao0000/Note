## volatile关键字

### 1. 实现原理

此关键字修饰的变量保证了共享变量的“**可见性**”，也就是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值，Java线程内存模型确保所有线程看到这个变量的值是一致的。

有volatile变量修饰的共享变量进行写操作时会有**lock指令**，Lock前缀的指令在多核处理器下会引发两件事：

- **Lock前缀指令会引起当前处理器缓存行数据回写到内存**。
- **这个写回内存的操作会使在其他CPU缓存了该内存地址的数据无效**。

若对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将此变量**所在缓存行**数据写回到系统内存。多处理器时为保证各处理器缓存一致，就会实现**缓存一致性协议**：每个处理器通过**嗅探**在总线上传播的数据来检查自己缓存的值是不是过期了，若发现自己缓存行对应的内存地址被修改，就会将**当前处理器的缓存设置为无效状态**。若处理器要对这个数据进行修改时，会重新从系统内存中把数据读到处理器缓存里。

### 2. 内存语义

#### 2.1 volatile的特性

volatile变量有下列特性：

- **可见性**。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。
- **原子性**：对任意单个volatile变量的读、写具有原子性，但类似volatile++这种**复合操作**不具有原子性。

#### 2.2 volatile写 - 读建立的happend-before关系

从内存语义来说，volatile的写 - 读 与锁的的释放 - 获取具有相同内存效果：volatile写和锁的释放有相同内存语义；volatile读与锁的获取有相同语义，**即对一个volatile变量的写操作先行发生于后面对这个变量的读操作**。

#### 2.3 volatile写 - 读的内存语义

- 当写一个volatile变量：JMM会把该线程对应的本地内存中共享变量值刷新到主内存。
- 当读一个volatile变量：JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。

所以可以做个总结：线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了消息（更改了共享变量）；线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的消息；线程A写一个volatile变量，随后线程B读这个volatile变量，此过程实质上是**线程A通过主内存向线程B发送消息**。

#### 2.4 volatile内存语义实现

先看一下JMM中对volatile变量定义的特殊重排序规则：

- 当第二个操作是volatile写时，不管第一个操作是什么都不能重排序。此规则确保volatile写之前的操作不会重排到volatile写之后。
- 当第一个操作是volatile读时，不管第二个操作是什么都不能重排序。此规则确保volatile读之后的操作不能重排到读之前。
- 当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。

为实现volatile内存语义，编译器在生成字节码时，会在指令序列中插入**内存屏障**来禁止特定类型的处理器重排序。JMM不保证插入屏障的最优，采用**保守策略**、这些策略非常的保守，不会有任何的优化或者缩减，总是会执行：

- 在每个volatile写操作的前面插入一个StoreStore屏障
- 在每个volatile写操作的后面插入一个StoreLoad屏障
- 在每个volatile读操作的后面插入一个LoadLoad屏障
- 在每个volatile读操作的后面插入一个LoadStore屏障

![img](https://note.youdao.com/yws/public/resource/56347de0c9d0b624bcbb02366ca7a2b8/xmlnote/BF03D397588E49B5B52DE5DC2FDBF7FD/BDA8E17A1BBF4FB1BC42EC5687D9FAFB/4727)

上图为volatile写操作的指令排序情况：

- 其中的StoreStore屏障将保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了，这是因为StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存。
- volatile写后面的StoreLoad屏障，此屏障的作用是避免volatile写与后面可能有的volatile读 / 写操作重排序，因为编译器无法判断在volatile写的后面是否需要插入一个StoreLoad屏障。所以采取了保守策略：在每个volatile写的后面或者volatile读的前面插入一个StoreLoad屏障。

![img](https://note.youdao.com/yws/public/resource/56347de0c9d0b624bcbb02366ca7a2b8/xmlnote/BF03D397588E49B5B52DE5DC2FDBF7FD/DA6D4ACE52524952BCA52DA5D342B927/4747)

上图为volatile写操作的指令排序情况：

- LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序
- LoadStore屏障用来禁止把处理器上面的volatile读与下面的普通写重排序



## 二、synchronized关键字

synchronized用来给一个对象加锁，它实现同步的基础是：Java中的每一个对象都可以作为锁。具体如下：

- 对于**普通同步方法**，锁是当前实例对象
- 对于**静态同步方法**，锁是当前类的Class对象
- 对于**同步方法块**，锁是Synchronized括号里配置的对象

Synchronized在JVM里的实现原理：JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用另一种方式。

monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。**任何对象都有一个monitor与之关联**，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，会尝试获取对象所对应的monitor所有权，即尝试获得对象的锁。

### 1. synchronized内存语义

- 进入synchronized块的内存语义就是把在synchronized块内使用到的变量从线程的工作内存中清除，这样块内使用变量时**不会从线程的工作内存中获取，而是直接从主内存中获取**。
- 退出synchronized块的内存语义就是把synchronized块内对共享变量的**修改刷新到主内存**。

### 2. Java对象头

synchronized用的锁是存在Java对象头里的，如果对象是数组类型，则虚拟机用3个字宽（1字宽为4字节）存储对象头，否则为2个字宽。对象头里的Mark Word默认存储对象的HashCode、分代年龄和锁标记位。32位JVM的Mark Word默认存储结构如表所示：

| **锁状态** | **25bit**      | **4bit**     | **1bit是否是偏向锁** | **2bit锁标志位** |
| ---------- | -------------- | ------------ | -------------------- | ---------------- |
| 无锁状态   | 对象的hashCode | 对象分代年龄 | 0                    | 01               |

运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化，可能变化为存储以下4种数据 ：

| **锁状态** | **25bit**                    | **4bit**         | **1bit**     | **2bit** |      |
| ---------- | ---------------------------- | ---------------- | ------------ | -------- | ---- |
| **23bit**  | **2bit**                     | **是否是偏向锁** | **锁标志位** |          |      |
| 轻量级锁   | 指向栈中锁记录的指针         | 00               |              |          |      |
| 重量级锁   | 指向互斥量（重量级锁）的指针 | 10               |              |          |      |
| GC标记     | 空                           | 11               |              |          |      |
| 偏向锁     | 线程ID                       | Epoch            | 对象分代年龄 | 1        | 01   |

### 3. 锁的升级与对比

Java SE 1,6为减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，锁一共有4种状态，级别从低到高一次是：**无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态**。这几个状态会随着竞争状态逐渐升级，**但锁可升级不可降级**，此策略目的是为了提高获得锁和释放锁的效率。

#### 3.1 偏向锁

因为HotSpot作者发现，大多情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在**对象头**和**栈帧**中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下**对象头的Mark Word里是否存储着指向当前线程的偏向锁**。若测试成功表示线程已经获得了锁；若测试失败，则需要再测试一下Mark Word中偏向锁的表示是否设置为1（表示当前为偏向锁），如果没有则使用CAS竞争锁，若设置了则尝试使用CAS将对象头的偏向锁指向当前线程。

（1）偏向锁的撤销

偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的释放需要等待**全局安全点**（这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置为无锁状态；如果线程仍然活着，持有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

（2）关闭偏向锁

可通过设置JVM参数 -XX:BiasedLockingStartupDelay=0来关闭偏向锁的激活延迟，也可通过参数-XX:UseBiasedLocking=false来关闭偏向锁，那么程序默认会进入轻量级锁状态。

#### 3.2 轻量级锁

（1）轻量级锁加锁

线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，**并将对象头中的Mark Word复制到锁记录中**，官方称为**Displaced Mark Word**。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争所，当前线程便尝试使用自旋来获取锁。

（2）轻量级锁解锁

轻量级锁解锁时，会使用CAS操作**将Displaced Mark Word替换回到对象头**，如果成功表示没有竞争发生。如果失败表示当前锁存在竞争，锁就会**膨胀成为重量级锁**。

因为自旋会消耗CPU，为了避免无用的自旋，一旦锁升级成为重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。

#### 2.3 锁的优缺点对比

| 锁       | 优点                                                         | 缺点                                         | 适用场景                           |
| -------- | ------------------------------------------------------------ | -------------------------------------------- | ---------------------------------- |
| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距 | 若线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块的场景 |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序响应速度                       | 若始终得不到锁竞争的线程，使用自旋会消耗CPU  | 追求响应时间 同步块执行速度非常快  |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU                              | 线程阻塞，响应时间缓慢                       | 追求吞吐量 同步块执行速度疆场      |