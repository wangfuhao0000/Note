### 进程

- 进程不只是一段可执行程序代码，还包括其它的资源，例如打开的文件、挂起的信号、内核内部数据、处理器状态、一个或多个具有内存映射的内存地址空间、一个或多个执行线程、用来存放全局变量的数据段等。
- 线程是进程中活动的对象，每个线程都有一个独立的程序计数器、进程栈和一组进程寄存器。**内核调度的对象是线程，而不是进程**。但其实对于Linux来说，对于进程和线程不做区分，线程是一种特殊的进程。

现在的操作系统中，进程提供了两种虚拟机制：

- 虚拟处理器：进程好像自己在独享处理器，但可能多个进程在共用一个处理器。
- 虚拟内存：进程在分配和管理内存时，好像自己拥有整个系统的所有内存资源。

**线程之间是共享虚拟内存，但每个线程却都有各自的虚拟处理器**。



Linux中通常调用`fork()`函数来创建新进程。该系统调用通过复制一个现有进程来创建一个全新的进程。调用`fork()`的进程称为父进程，新创建的为子进程。系统调用结束后，在返回点这个位置上，父进程恢复执行，子进程开始执行。所以`fork()`系统调用从内核中返回两次：**一次回到父进程，一次回到新产生的子进程**。

创建新进程后一般是为了立即执行新的、不同的程序，所以会紧接着调用`exec()`这组函数来**创建新的地址空间**，并把程序载入其中。

最后，程序通过`exit()`系统调用退出执行。这个函数会终结进程并将其中占用的资源释放掉。父进程可通过`wait4()`系统调用来查询子进程是否终结，这使得进程拥有了等待特定进程执行完毕的能力。进程执行完毕后被设置为**僵死状态**，直到它的父进程调用`wait()`或`waitpid()`为止。

### 进程描述符及任务结构

内核会把进程的列表存放在叫做任务队列的**双向循环链表**中。链表中的每一项都是`task_struct`结构，称为**进程描述符**。此结构存储了一个具体进程的所有信息：它打开的文件，进程的地址空间，挂起的信号，进程的状态...

##### 进程描述符的存放？？

**内核通过一个唯一的进程标识值或PID来标识每个进程**，内核把每个进程的PID放在它们各自的进程描述符中。

##### 进程状态

进程描述符中的`state`域描述了进程的当前状态，一个进程可以有以下5种状态：

- TASK_RUNNING（运行）——进程是可执行的：正在执行，或在运行队列中等待执行。**这是在用户空间中执行的唯一可能的状态**。
- TASK_INTERRUPTIBLE（可中断）——进程正在睡眠（或被阻塞），等待某些条件的达成被唤醒，继而变为运行状态。
- TASK_UNINTERRUPTIBLE（不可中断）——与可中断状态类似，只是当处于此状态时就算接收到信号也不会被唤醒。
- _TASK_TRACED——被其他进程跟踪的进程
- _TASK_STOPPED（停止）——进程停止运行

##### 设置当前进程状态

当要调整某个进程的状态时，最好使用`set_task_state(task, state)`函数：

```c
set_task_state(task, state);    
```

该函数将指定的进程设置为指定的状态，必要时，它会设置内存凭证来强制其他处理器作重排序。

##### 进程上下文

可执行代码从一个可执行文件载入到进程的地址空间执行。一般程序在用户空间执行，当一个程序执行了系统调用或触发了某个异常，就会陷入到内核空间。**系统调用**和**异常处理程序**是对内核明确定义的接口，进程只有通过这些接口才能陷入内核执行——即对内核的访问都必须通过这些接口。

##### 进程家族树

Linux中，所所有进程都是**PID为1的init进程**的后代，内核在系统启动的最后阶段启动init进程，该进程读取系统的初始化脚步并执行其它相关的程序，最终完成系统的启动过程。

系统中的每个进程必有一个父进程，每个进程也可拥有零个或多个子进程。进程间的关系存放在进程描述符中，每个`task_struct`都包含一个指向其父进程`task_struct`、叫做parent的指针，还包含一个称为children的子进程链表。由于所有的`task_struct`结果都是通过双向链表存起来的，所以可通过一个进程来遍历其他的所有进程，当然效率比较低。

### 进程创建

进程创建一般的过程为：首先在新的地址空间里创建进程，读入可执行文件，最后开始执行。Linux将此过程分成了两步到两个单独的函数中：`fork()`和`exec()`。

- fork()：拷贝当前进程来创建一个子进程，子进程与父进程的区别仅仅在于PID、PPID和某些资源和统计量。
- exec()：读取可执行文件并将其载入地址空间开始运行。

##### 写时拷贝

因为传统的`for()`函数会将父进程的资源复制给子进程，但如果两进程的数据并不需要共享，而且子进程打算立即执行一个新的映像，那么所有的拷贝就没有意义了。所以Linux的`fork()`使用了**写时拷贝**页实现，它是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。

只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。在此之前，只是以读方式共享，这样如果调用完`fork()`后紧接着调用`exec()`则就不会发生拷贝现象的了。此时`fork()`的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符，所以Linux中进程创建很快。

##### fork()

Linux中的`fork()`、`vfork()`、`_clone()`库函数都是通过`clone()`系统调用来实现，此调用通过一系列的参数标志来指明父、子进程需要共享的资源。`clone()`系统调用调用了`do_fork()`函数，此函数先调用`copy_process()`函数，然后让进程开始运行。



先看看`copy_process()`的工作：

1. 调用`dup_task_struct()`为进程创建一个内核栈、`thread_info`结构和`task_struct`，这些值与当前进程的值相同，此时子进程和父进程的描述符完全相同。（**超级结构**）
2. 检查创建完此进程后，当前用户拥有的进程数目没有超出给它分配的资源的限制。
3. 修改进程描述符中的一些成员，主要是一些统计信息，来让子进程和父进程区分开。
4. 子进程的状态被设置成TASK_UNINTERRUPTIBLE，保证它不会被投入运行。
5. `copy_process()`调用`copy_flags()`来更新`task_struct`的`flags`成员：表示进程是否拥有超级用户权限的PF_SUPERPRIV标志被清0，表明进程还没有调用`exec()`函数的PF_FORKNOEXEC标志被设置。
6. 调用`alloc_pid()`为新进程分配一个有效的PID。（**分配PID**）
7. 根据传递给`clone()`的参数标志，`copy_process()`拷贝或共享打开的文件、文件系统信息、进程地址空间和命名空间等。**通常这些资源被进程内的线程共享，而不同的进程是不同的**。
8. 最后，`copy_process()`返回一个指向子进程的指针。



在`do_fork()`中调用完`copy_process()`成功返回后，新创建的子进程被唤醒并让其投入运行。内核有意选择子进程首先执行。因为一般子进程都会马上调用`exec()`函数，这样可以避免写时拷贝的额外开销。

### 线程在Linux中的实现

从内核角度来看，Linux没有线程，它把所有的线程都当中进程来实现，**线程仅仅被视为一个与其他进程共享某些资源的进程**。每个线程都拥有唯一隶属于自己的`task_struct`，所以在内核中它看起来就像是一个普通的进程。其它操作系统中对于进程都有专门的实现，而对Linux来说，线程只是一种进程间共享资源的手段。

如果其它系统创建包含四个线程的进程时，需要在进程中有一个包含指向四个不同线程的指针的进程描述符，该描述符负责描述例如地址空间、打开的文件等共享资源。线程本身再去描述它独占的资源。相反，Linux仅仅创建四个进程并分配四个普通的`task_struct`结构，建立这是个进程时指定它们共享某些资源。

##### 创建线程

线程的创建和普通进程的创建类似，只是在`clone()`的时候需要传递一些**参数标志**来指明需要共享的资源：

```c
clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0);
```

一些参数列表可自行查找。

##### 内核线程

内核在后台需要执行一些操作，而这些任务可通过**内核线程**完成——独立运行在内核空间的标准进程。**内核线程和普通的进程的区别在于内核线程没有独立的地址空间**。它们只在内核空间运行，从来不切换到用户空间去，所以也就不需要独立的地址空间。

内核线程也是由其他内核线程创建的，内核通过从`kthreadd`内核线程中衍生出所有新的内核线程来自动处理这一点，具体的创建过程就不描述了。内核线程启动后就一直运行直到调用`do_exit()`退出。

### 进程终结

当一个进程终结时，内核必须释放它所占用的资源并告知给父进程，通常是调用`exit()`系统调用时来终结。它主要完成以下的工作：

1. 将`task_struct`中的标志成员设置为PF_EXITING。
2. 调用





## 进程间的通信方式

进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。IPC的方式通常有**管道（包括无名管道和命名管道）**、**消息队列**、**信号量**、**共享存储**、**Socket**、**Streams**等。其中 Socket和Streams支持不同主机上的两个进程IPC。

以Linux中的C语言编程为例。

### 一、管道（无名管道）

**1、特点：**

1. 它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。
2. 它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。
3. 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

**2、原型：**

```
#include <unistd.h>
int pipe(int fd[2]);    // 返回值：若成功返回0，失败返回-1
```

当一个管道建立时，它会创建两个文件描述符：fd[0]为读而打开，fd[1]为写而打开。要关闭管道只需将这两个文件描述符关闭即可。如下图：

![img](https://note.youdao.com/yws/public/resource/1cdba699ec7b6efece55aae67366a809/xmlnote/wcp1578829999021285/75953240D7E344449FE00A840B06D0A8/13173)

**3、例子**

单个进程中的管道几乎没有任何用处。所以，通常调用 pipe 的进程接着调用 fork，这样就创建了父进程与子进程之间的 IPC 通道。如下图所示：

![img](https://note.youdao.com/yws/public/resource/1cdba699ec7b6efece55aae67366a809/xmlnote/wcp1578829999021285/894A70D3AF504F45A600FBBA26CBF602/13177)

若要数据流从父进程流向子进程，则关闭父进程的读端（fd[0]）与子进程的写端（fd[1]）；反之，则可以使数据流从子进程流向父进程。

### 二、FIFO（命名管道）

**1、特点**

1. FIFO可以在无关的进程之间交换数据，与无名管道不同。
2. FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

**2、原型**

```
#include <sys/stat.h>
// 返回值：成功返回0，出错返回-1
int mkfifo(const char *pathname, mode_t mode);
```

其中的 mode 参数与open函数中的 mode 相同。一旦创建了一个 FIFO，就可以用一般的文件I/O函数操作它。

当 open 一个FIFO时，是否设置非阻塞标志（O_NONBLOCK）的区别：

- 若没有指定O_NONBLOCK（默认），只读 open 要阻塞到某个其他进程为写而打开此 FIFO。类似的，只写 open 要阻塞到某个其他进程为读而打开它。
- 若指定了O_NONBLOCK，则只读 open 立即返回。而只写 open 将出错返回 -1 如果没有进程已经为读而打开该 FIFO，其errno置ENXIO。

上述例子可以扩展成 客户进程—服务器进程通信的实例，write_fifo的作用类似于客户端，可以打开多个客户端向一个服务器发送请求信息，read_fifo类似于服务器，它适时监控着FIFO的读端，当有数据时，读出并进行处理，但是有一个关键的问题是，每一个客户端必须预先知道服务器提供的FIFO接口，下图显示了这种安排：

![img](https://note.youdao.com/yws/public/resource/1cdba699ec7b6efece55aae67366a809/xmlnote/wcp1578829999021285/1C7B4BC27C794C28BDA2F376B6215E50/13189)

### 三、消息队列

消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。

**1、特点**

1. 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。
2. 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。
3. 消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取,也可以按消息的类型读取。

### 四、信号量

信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。

**1、特点**

1. 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
2. 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。
3. 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。
4. 支持信号量组。

**2、原型**

最简单的信号量是只能取 0 和 1 的变量，这也是信号量最常见的一种形式，叫做二值信号量（Binary Semaphore）。而可以取多个正整数的信号量被称为通用信号量。

Linux 下的信号量函数都是在通用的**信号量数组**上进行操作，而不是在一个单一的二值信号量上进行操作。

### 五、共享内存

共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。

**1、特点**

1. 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。
2. 因为多个进程可以同时操作，所以需要进行同步。
3. 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

**2、原型**

当一段共享内存被创建以后，它并不能被任何进程访问。必须使用shmat函数连接该共享内存到当前进程的地址空间，连接成功后把共享内存区对象**映射**到调用进程的地址空间，随后可像本地空间一样访问。shmdt函数是用来断开shmat建立的连接的。注意，这并不是从系统中删除该共享内存，**只是当前进程不能再访问该共享内存而已。**

在Linux中，每个进程都有属于自己的进程控制块（PCB）和地址空间（Addr Space），并且都有一个与之对应的页表，负责将进程的虚拟地址与物理地址进行映射，通过内存管理单元（MMU）进行管理。两个不同的虚拟地址通过页表映射到物理空间的同一区域，它们所指向的这块区域即共享内存。共享内存的通信原理示意图：

![img](https://note.youdao.com/yws/public/resource/1cdba699ec7b6efece55aae67366a809/xmlnote/wcp1582301420925209/3C594E93233D4DA994111B0DAC78E647/19996)

对于上图我的理解是：当两个进程通过页表将虚拟地址映射到物理地址时，在物理地址中有一块共同的内存区，即共享内存，这块内存可以被两个进程同时看到。这样当一个进程进行写操作，另一个进程读操作就可以实现进程间通信。但是，我们要确保一个进程在写的时候不能被读，因此我们使用**信号量来实现同步与互斥**。

对于一个共享内存，实现采用的是**引用计数**的原理，当进程脱离共享存储区后，计数器减一，挂架成功时，计数器加一，只有当计数器变为零时，才能被删除。当进程终止时，它所附加的共享存储区都会自动脱离。

**3、为什么共享内存速度最快？**

借助上图说明：Proc A 进程给内存中写数据， Proc B 进程从内存中读取数据，在此期间一共发生了两次复制

（1）Proc A 到共享内存       （2）共享内存到 Proc B

因为直接在内存上操作，所以共享内存的速度也就提高了。

总结：

（1）优点：我们可以看到使用共享内存进行进程之间的通信是非常方便的，而且函数的接口也比较简单，数据的共享还使进程间的数据不用传送，而是直接访问内存，加快了程序的效率。

（2）缺点：共享内存没有提供同步机制，这使得我们在使用共享内存进行进程之间的通信时，往往需要借助其他手段来保证进程之间的同步工作。

### 通信方式总结

1.管道：速度慢，容量有限，只有父子进程能通讯    

2.FIFO：任何进程间都能通讯，但速度慢    

3.消息队列：容量受到系统限制，**且要注意第一次读的时候，要考虑上一次没有读完数据的问题**

4.信号量：不能传递复杂消息，只能用来同步    

5.共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存