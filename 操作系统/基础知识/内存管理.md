## 页

内核把物理页作为内存管理的基本单位。**尽管处理器的最小可寻址单位通常为字（或字节），但是内存管理单元（MMU，负责把虚拟地址转换为物理地址的硬件）通常以页为单位进行处理**。所以从虚拟内存角度来看，页就是最小单位。

内核使用`struct page`结构标识系统中的每个物理页：

```c
struct page {
	unsigend long flags;  // 页的状态，是否脏。是否被锁在内存中。每一位标识一种状态，所以至少可表示32种状态
	atomic_c _count;      // 页的引用数，被引用了多少次。变为-1表示内核没有引用此页。需使用page_count()函数来检查该域
	atomic_t _mapcount;
	unsigned long private;
	struct address_space *mapping;
	pgoff_t index;
	struct list_head lru;
	void *virtual;   // 页的虚拟地址，有些内存（如高端内存）不永久映射到内核地址空间上，此时它为NULL。
};
```

page结构与物理页相关而非虚拟页。即使这个页里面的数据还存在，但也会由于交换等原因导致不再和同一个page结构相关联。这种结构的目的在于描述物理内存本身，而不是描述包含在其中的数据。

内核用它来管理系统中的页，因为内核需要知道一个页的状态（是否空闲，谁拥有这个页）。而且每个物理页都需要分配这样的一个结构体。

## 区

内核不会对所有的页一视同仁，因为有些页位于内存特定物理位置上，不能将其用于一些特殊任务。因此内核把页划分为了不同的区，**使用区对具有相似特性的页进行分组**。Linux需要处理下面两种由于硬件缺陷而引起的内存寻址问题：

- 一些硬件只能用某些特定的内存地址来执行DMA（直接内存访问）。
- 一些体系结构的内存的物理寻址范围比虚拟寻址范围大得多，这样一些物理内存不能永久的映射到内核空间上。

由于这些制约条件，Linux主要使用了四种区：

- ZONE_DMA——这个区包含的页用来执行DMA操作
- ZONE_DMA32——和上面类似，但它们只能被32位设备访问。
- ZONE_NORMAL——包含的都是能正常映射的页
- ZONE_HIGHEM——这个区包含“高端内存”，**其中的页不能永久地映射到内核地址空间**。

Linux把系统地页划分为区，形成不同地内存池，就可以根据用途进行分配了。例如ZONE_DMA区让内核有能力为DMA分配所需内存，但区的划分没有任何物理意义，只不过是内核为了管理页而采取地一种逻辑上地分组（和Java对于堆分为新生代和老年代的思路类似）。

某些分配可能需要从特定的区中获取页，而另外一些分配则可以从多个区中获取页。例如用于DMA的内存必须从ZONE_DMA中分配，但一般用途的内存既可从ZONE_DMA也可从ZONE_NORMAL分配。但不能同时从两个区分配，**因为分配是不能跨区界限的**。

不是所有的体系结构定义了所有区，例如Intel的x86-64体系结构没有ZONE_HIGHMEM区，物理内存均在ZONE_DMA和ZONE_NORMAL区中。每个区用struct zone表示，其中：

- lock域是个自旋锁，防止**该结构被并发访问**。它只保护结构，不保护驻留在这个区的所有页。
- watermark持有该区的最小、最低和最高水位值。内核使用水位为每个内存区设置合适的内存消耗基准。该水位随空闲内存的多少而变化。

## 获得页

内核提供了一种请求内存的底层机制，并提供了对他访问的几个接口。这些接口都以页为单位分配内存，定义于<linux/gfp.h>中，最核心的函数是：

```c
struct page * alloc_pages(gfp_t gfp_mask, unsigend int order);
```

它分配