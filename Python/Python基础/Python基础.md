## Python变量类型

python有五个标准的数据类型：

- Numbers（数字）
- String（字符串）
- List（列表）
- Tuple（元组）
- Dictionary（字典）

### 数字

数字数据类型时不可改变的，意味着改变数字数据类型会分配一个新的对象。可以使用del语句删除一个或多个对象的引用。

```python
var1 = 1
var2 = 10
del var1[, var2, ...]
```

Python支持四种不同的数字类型：

- int（有符号整型）
- long（长整型，再python3.x中被移除，使用int代替）
- float（浮点型）
- complex（复数）

### 字符串

Python不支持单字符类型，单字符在Python中也是作为一个字符串使用。

python的字符串列表有两种取值顺序：

- 从左到右索引默认0开始的，最大范围时字符串长度减1
- 从右到左索引默认-1开始，最大范围时字符串开头

当腰截取一个子串时，可以使用`[头下标 : 尾下标]`来截取，当然其中不包括尾下标所在的字符，此时截取出来的是个新的对象。且字符串不允许进行某个位置上的赋值，例如`s[3] = "b"`会报错。

字符串的连接可以使用符号"+"，也可以使用星号"*"后面跟重复的次数。

### 列表

列表时一个集合类的数据结构，使用`[]`标识，是一个通用的复合数据类型，即里面的数据可以是不同类型的。列表中值的切割也可以使用变量`[头下标 : 尾下标]`来进行截取，下标为空表示取到头或尾。

同样的加号`+`时列表连接运算发，星号`*`是重复操作。

我们可以对列表的数据项进行修改或更新；也可以使用`append()`方法来添加列表项；当然也可以使用`del`语句来删除列表的元素。

### 元组

元组和List列表类似，使用`()`标识，内部用逗号隔开。**但是元组不能二次赋值，相当于只读列表**。

同样元组是不允许删除的，但可以使用`del`语句来删除整个元组。

任何无符号的对象，以逗号隔开，默认为元组，例如：

```python
#!/usr/bin/python
 
print 'abc', -4.24e93, 18+6.6j, 'xyz'
x, y = 1, 2
print "Value of x , y : ", x,y
```

### 字典

列表是一个有序的对象集合，而字典对应是无序的。字典使用`{}`标识，并由索引(key)和它对应的值(value)来组成一个字典。

**字典中的值可以取任何数据类型，但键必须是不可变的，例如字符串，数字或元组**。

更新和添加操作都是使用直接赋值的方式，而删除操作则是使用`del`命令，其中可以删除其中的一个条目，也可以删除整个字典。

### 数据类型转换

数据类型的转换，只需要将数据类型作为函数名即可。

![image-20200630164308612](E:%5CNote%5CPic%5Cimage-20200630164308612.png)

## 条件语句

Python指定任何非0和非空（null）值为true，0或者null为false。

Python中不支持switch语句，所以多个条件判断只能用elif来实现。

## 循环语句

while循环中可以添加else语句，用于在循环条件为false时执行else语句块。

```python
#!/usr/bin/python
 
count = 0
while count < 5:
   print count, " is  less than 5"
   count = count + 1
else:
   print count, " is not less than 5"
```

类似的for...else标识在for循环结束后，else中的语句会在循环正常执行完的情况下执行，但不能是通过break跳出而中断的。

## 函数

要注意在Python中一切都是对象，但分为可更改(mutable)与不可更改(immutable)对象，其中strings，tuples和numbers是不可更改的对象，而list，dict等则是可修改的对象。

- 不可变类型：变量赋值a=5后再赋值a=10，这里时即是新生成一个int值对象10，再让a指向它，而5被丢弃，不是改变啊的值相当于新生成了a。
- 可变类型：变量赋值`la=[1,2,3,4]`后再赋值`la[2]=5`则是将list la的第三个元素更改，本身la没有动，只是其内部的一部份值被修改了。

而在python函数的参数传递过程中：

- 不可变类型：传递的只是参数a的值，没有影响a对象本身。比如在`fun(a)`内部修改a的值，只是修改另一个复制的对象，不会影响a本身。
- 可变类型：真正的将参数传递过去了，内部修改会对外部有一定的影响。

### 参数

下面是调用函数时可使用的正式参数类型：

- 必备参数
- 关键字参数
- 默认参数
- 不定长参数

#### 必备参数

必备参数必须以正确的顺序传入函数，调用时的数量必须和声明时的一样。

#### 关键字参数

函数调用使用关键字参数来确定传入的参数值，使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为Python解释器能够用参数名匹配参数值。

```python
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
def printinfo( name, age ):
   "打印任何传入的字符串"
   print "Name: ", name
   print "Age ", age
   return
 
#调用printinfo函数
printinfo( age=50, name="miki" )
```

#### 默认参数

调用函数时，默认参数的值如果没有传入，则被认为是默认值。

```python
def printinfo( name, age = 35 ):
   "打印任何传入的字符串"
   print "Name: ", name
   print "Age ", age
   return
 
#调用printinfo函数
printinfo( age=50, name="miki" )
printinfo( name="miki" )
```

#### 不定长参数

当定义函数时，加了星号（*）的变量名会存放所有未命名的变量参数。

```python
# 可写函数说明
def printinfo( arg1, *vartuple ):
   "打印任何传入的参数"
   print "输出: "
   print arg1
   for var in vartuple:
      print var
   return
 
# 调用printinfo 函数
printinfo( 10 )
printinfo( 70, 60, 50 )
```

### 匿名函数

python使用Lambda来创建匿名函数

- lambda主体是个表达式，而不是个代码块，所以只能封装有限的逻辑进去。
- lambda函数有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。

lambda语法如下：

```python
lambda [arg1, ] : expression

sum = lambda arg1, arg2 : arg1 + arg2
```



## Python模块

**Python模块是个Python文件，以.py结尾**，包含了Python对象定义和Python语句。

### import语句

模块定义好后，我们可以使用import语句来引入模块，语法如下：

```python
import module1, ...
```

当使用模块中的函数时，需要这样使用

```
模块名.函数名0
```

解释器遇到import语句，如果模块在当前的搜索路径就会被导入。不管执行了多少次import，一个模块只会被导入一次。

### from...import语句

from语句可以让你**从模块中导入一个指定的部分**到当前命名空间中，语法如下：

```python
from modname import name1, ...
```

也可以使用`from... import *`把一个模块下的所有内容，当然内容过多时不推荐这种方式。

### 搜索路径

当导入一个模块，Python解析器对模块位置的搜索顺序是：

1. 当前目录
2. 如果不在当前目录，Python则搜索在shell变量PYTHONPATH下的每个目录
3. 如果都找不到，Python会查看默认路径。UNIX下一班是/usr/local/lib/python

### 命名空间和作用域

变量是拥有匹配对象的名字，而命名空间是一个包含了变量名称们（键）和它们各自相应的对象们（值）的字典。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。Python假设任何在函数内赋值的变量都是局部的，因此如果要给函数内的全局变量赋值，必须使用**global语句**。

### dir()函数

dir()函数返回一个排好序的字符串列表，**内容是一个模块里定义过的名字。返回的列表容纳了在一个模块里定义的所有模块，变量和函数**。

### globals()和locals()函数

根据调用地方不同，glabals()和locals()函数可被用来返回全局和局部命名空间里的名字：

- 若在函数内部调用locals()，返回的是所有能在该函数里访问的命名
- 若在函数内部调用globals()，返回的是所有在该函数里能访问的全局名字

两个函数的返回类型都是**字典**，所以名字可以使用`keys()`函数获得

### reload()函数

当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。因此如果想重新执行模块里顶层部分的代码，可以用`reload()`函数，该函数会重新导入之前导入过的模块：

```python
reload(module_name)  # module_name要放模块的名字，而不是字符串
```

### Python中的包

一个包定义了一个由模块及子包，和子包下的子包等组成的Python应用环境。包的文件夹必须存在`__init__.py`文件用于标识当前文件夹是一个包。

## Python异常处理

### 异常处理

捕获异常可以使用`try/except`语句，下面是它的用法

```python
try:
<语句>        #运行别的代码
except <名字>：
<语句>        #如果在try部份引发了'name'异常
except <名字>，<数据>:
<语句>        #如果引发了'name'异常，获得附加的数据
else:
<语句>        #如果没有异常发生
```

当使用except时可以不带任何异常类型，也可以带多种异常类型。

### 触发异常

我们可以使用`raise`语句来自己触发异常，raise语法格式如下：

```python
raise [Exception [, args [, traceback]]]
```

### 用户自定义异常

通过创建一个新的异常类，程序可命名自己的异常，通常直接或间接继承自Exception类。