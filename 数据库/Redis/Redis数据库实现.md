**1. 服务器端和客户端**

所有数据库都是保存在redisServer结构的db数组中，每一项都是一个数据库，默认创建16个。

```
struct redisServer {
    redisDb *db;
};
```

客户端切换数据库时（**SELECT** 命令）就是让自己的db指针指向redisServer中db数组的不同位置，客户端结构如下：

```
typedef struct redisClient {
    redisDb *db;  //指向redisServer中db的某一个
} redisClient;
```

**2. 数据库键空间**

上面说到一个数据库就是一个redisDb结构，他里面的**dict字典**保存了此数据库内所有键值对，称为**键空间**：

```
typedef struct redisDb {
    dict *dict;
}
```

键空间的键存数据库的键，每个键是个字符串对象；键空间的值是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。所以对于数据库的各种操作如添加、删除等都是对键空间进行操作来实现的。

- **添加新键：**实际就是将一个新键值对添加到键空间字典里，键为字符串对象，值为任意一种类型的Redis对象。
- **删除键：**实际就是在键空间里面删除键对应的键值对对象
- **更新键：**实际就是对键空间里面键对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。
- **对键取值：**实际就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。
- **其他键空间操作：**清空数据库的**FLUSHDB**命令：删除键空间中所有键值对；返回数据库键数量的**DBSIZE**命令：返回键空间中包含的键值对数量

**读写键空间时的维护操作****（重要）**

对键空间执行指定读写操作时会执行一些额外的维护操作：

- 读取一个键后（读操作和写操作都会读取），服务器会根据键是否存在来更新服务器的**键空间命中次数**或**键空间不命中次数**。
- 读取一个键后，会更新此键的**LRU**（最后一次使用）时间，它可用来计算键的**闲置时间**。
- 若服务器读取一个键时发现它已过期，则会先删除这个键再执行其他操作。
- 若有客户端使用**WATCH**命令**监视**某个键，服务器修改这个键时会把它标记为**脏（dirty）**
- 服务器每次修改一个键，都会对脏键计数器的值加1，此计数器会触发服务器的持久化以及复制操作。
- 若服务器开启了**数据库通知功能**，则修改键时，服务器会按配置发送相应的数据库通知。

**3. 设置键的生存或过期时间**

- **EXPIRE****（****PEXPIRE****）命令：**以秒或毫秒精度为数据库中某个键设置**生存时间（TTL）**。
- **EXPIRE****AT****（****PEXPIRE****AT****）命令：**以秒或毫秒精度为数据库中某个键设置**过期时间（expire time）**。
- **TTL****（****PTTL****）命令：**返回某个键的剩余生存时间，命令接受一个带有生存或过期时间的键。
- **SETEX****命令**：可设置键的同时设置过期时间，但它是个**类型限定命令**（只能作用于字符串键）。

上面四个和设置过期时间相关的命令都是使用**PEXPIREAT**命令实现的。即以毫秒设置键的过期时间

**保存过期时间**

redisDb结构中的expires字典保存了数据库中所有键的过期时间，称此字典为**过期字典**：

- 过期字典的键是个指针，指向键空间中某个键对象
- 过期字典的值是个llong long类型整数，保存了键所指向的数据库键的**过期时间**。（所以那四个命令都是用**PEXPIREAT**实现的）

**移除过期时间**

使用**PERSIST**命令可移除一个键的过期时间，它在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。

**计算并返回剩余生存时间**

**TTL**命令以秒为单位返回，**PTTL**命令则以毫秒为单位。这两个命令都是通过计算键的过期时间和当前时间之间的差来实现的。

**过期键的判定**

直接访问过期字典来检查一个给定键是否过期：

- 检查给定键是否存在于过期字典：若存在则取得过期时间。
- 检查当前UNIX时间戳是否大于键过期时间，若大于则键已过期，否则未过期。

**4. 过期键删除策略****（重要）**

有三种不同的删除策略，第一种和第三种为主动删除，第二种为被动删除：

- **定时删除**：设置键过期时间同时创建一个**定时器**，让定时器在键的过期时间来临时立即删除键。
- **惰性删除**：放任键过期不管，每次获取键的时候都检查一下，如果过期就删除，没过期则返回该键。
- **定期删除**：每隔一段时间就检查一次数据库，删除里面的过期键。

**定时删除**

此策略对内存最友好，因为只要键一过期就立即删除并释放内存；但它对CPU时间最不友好，因为每创建一个键都要创建一个定时器，这样可能会有多个定时器来不停检查键是否过期，占用许多CPU。

**惰性删除**

此策略对CPU时间最友好，因为它只针对要使用的键进行处理，其他不相关的键不会去管，用到才处理；但它对内存最不友好，因为如果好多过期的也是我们不再用的，那就会永远保留在内存中。

**定期删除**

算是上面两种策略的一种折中：

- 每隔一段时间执行一次删除过期键操作，并限制删除操作执行的**时长**和**频率**来减少删除操作对CPU时间的影响。
- 定期删除过期键有效减少了因为过期键而带来的内存浪费。

当然难点还是确定删除操作执行的**时长**和**频率**。

**5. Redis的过期键删除策略****（重要）**

Redis实际使用的是**惰性删除**和**定期删除**两种策略。

**惰性删除策略实现**

惰性删除策略由expireIfNeeded函数实现，在读写数据库前均会先执行此函数对输入键进行检查：若输入键已过期，则从数据库中删除此键；未过期则不做动作。因为每个被访问的键都会因过期被**expireIfNeeded**函数删除，所以每个命令都必须能同时处理键存在以及键不存在这两种情况。

**定期删除策略实现**

定期删除策略由activeExpireCycle函数实现，它在规定的时间内，**分多次**遍历服务器中各个数据库，从数据库的expires字典中**随机检查**一部分键的过期时间并删除过期键。它有一个变量current_db会记录检查进度，即检查到了第几个数据库，检查完一遍重置为0。随着此函数不断进行，服务器中所有数据库会被检查一遍。

**6. AOF、RDB和复制功能对过期键的处理**

**生成RDB文件**

在执行**SAVE**命令或者**BGSAVE**命令创建一个新RDB文件时，程序会对数据库中的键进行检查，过期的键不会保存到新建的RDB文件中。

**载入RDB文件**

启动服务器时若服务器开启了RDB功能，那么服务器将对RDB文件进行载入：

- 若服务器以**主服务器**模式运行，则会对文件中的键进行检查：未过期的载入到数据库中，过期的则被忽略。
- 若服务器以**从服务器**模式运行，则会保存文件中的所有键，均会载入到数据库中。不过因为主从服务器在进行**数据同步**时，从服务器数据库会被清空，所以同步后会和主服务器一致，没影响。

**AOF文件写入**

当服务器以AOF持久化模式运行时，若数据库中某个键已过期但还未被惰性删除或定期删除，那么AOF文件不会因为此过期键而产生变化。当过期键被惰性删除或者定期删除后，程序会向AOF文件追加一条**DEL****命令**，来显示记录该键已删除。

**AOF重写**

和生成RDB文件类似，执行AOF重写时，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。

**复制**

服务器运行在复制模式下时，从服务器的过期删除动作由主服务器控制：

- 主服务器在删除一个过期键后，会显示地向所有从服务器发送一个**DEL**命令，告知从服务器删除这个过期键。
- **从服务器**执行客户端的读命令时，即使碰到过期键也不会删除，而是正常返回此过期键。
- 从服务器只有接收到主服务器发来的**DEL**命令后，才会删除过期键。

**7. 数据库通知**

此功能可让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况