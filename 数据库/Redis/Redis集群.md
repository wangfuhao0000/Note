## 1. 节点

一个集群通常由多个节点构成，刚开始独立，若要组建集群，需将各个独立的节点连接起来构成一个包含多节点的集群。连接各个节点的工作可使用**CLUSTER MEET**命令来完成，格式如下：

```shell
CLUSTER MEET <ip> <port>
```

向一个节点node发送`CLUSTER MEET`命令时，可让node节点与ip和port所指定的节点进行握手，握手成功后，node节点就会将ip和port所指定的节点添加到**node节点当前所在的集群中**。

### 1.1 启动节点

一个节点就是一个运行在**集群模式**下的Redis服务器，Redis服务器在启动时会根据**cluster-enabled配置选项**是否为yes来决定是否开启服务器的集群模式。此后，节点会继续使用所有在单机模式中使用的服务器组件，例如：

- 使用**文件事件处理器**来处理命令请求和命令返回
- 使用**时间事件处理器执行serverCron函数，而此函数又会调用集群模式特有的clusterCron函数，它负责执行在集群模式下需要执行的常规操作，如检查节点是否断线、是否要进行故障转移

除此之外，节点会继续使用redisServer结构来保存服务器状态，使用redisClient保存客户端状态。至于那些只有在集群模式下才会用到的数据，节点将它们保存到了**clusterNode**结构、**clusterLink**结构和**clusterState**结构里。

**1.2 集群数据结构clusterNode**

- clusterNode结构保存了一个**节点的当前状态**，如节点创建时间、节点名字、节点当前的配置纪元、节点的IP地址和端口号等。每个节点使用一个clusterNode结构记录自己状态，并为**集群中所有其他节点**（包括主节点和从节点）都创建一个相应的clusterNode结构。
- clusterNode结构的link属性是一个**clusterLink**结构，该结果保存了连接节点所需的有关信息，如套接字描述符、输入和输出缓冲区。
- 最后每个节点都保存着一个**clusterState**结构，它记录了在当前节点的视角下，集群目前所处的状态。例如集群是在线还是下线，集群包含多少个节点，集群当前的配置纪元。

### 1.3 CLUSTER MEET命令实现（重要）

通过向节点A发送**CLUSTER MEET**命令，客户端可让接收命令的节点A将给定ip和port的节点B添加到节点A当前所在的集群里：

​    **CLUSTER MEET <ip> <port>**

收到命令的节点A将与节点B进行握手，以此来确认彼此的存在：

1. 节点A根据CLUSTER MEET命令给的IP和端口向节点B发送一条MEET消息。**(A向B发MEET)**
2. 之后节点B将向节点A返回一条PONG消息。节点A收到PONG消息后，知道节点B成功收到了自己的MEET消息。**(B向A返回PONG)**
3. 然后节点A将向节点B返回一条PING命令。节点B收到PING消息后，知道节点A成功接收了自己返回的PING消息。**(A向B发PING)**

这个过程有点类似于TCP三次握手

之后节点A会将节点B的信息通过Gossip协议传播给集群中其他节点，让其他节点也与节点B握手，经过一段时间后节点B会被集群中所有节点认识。

**2. 槽指派****（重要）**

Redis集群通过**分片**的方式保存数据库中键值对：集群的整个数据库被分为16384个槽（slot），数据库中的每个键都属于这16384个槽中的一个，集群中的每个节点可处理0或最多16384个槽。当数据库中的16384个槽都有节点在处理时，集群处于上线状态（OK）；相反地，如果数据库中有任何一个槽都没有得到处理，那集群处于下线状态（fail）。

通过向节点发送**CLUSTER ADDSLOTS**命令，可将一个或多个槽指派给节点负责

**2.1 记录节点的槽指派信息**

clusterNode结构的slots属性和numslot属性记录了节点负责处理哪些槽：

- **slots**是个**二进制位数组**，长度为16384/8=2048个字节，共包含16384个二进制位。若索引i上二进制位为1，则表示节点负责处理槽i，否则不处理槽i。
- **numslot**记录节点负责处理的槽的数量，即slots数组中值为1的二进制位数量。

**2.2 传播节点的槽指派信息**

一个节点除了将自己负责处理的槽信息记录在clusterNode结构的slots属性和numslots属性外，还会将自己的slots数组通过消息发送给集群中其他节点，告知自己当前负责处理哪些槽。

当节点A通过消息从节点B那里接收到节点B的slots数组时，节点A会在自己的clusterState.nodes字典中查找节点B对应的clusterNode结构，并对结构中的slots数组进行保存和更新。**因此集群中的每个节点都会知道数据库中的16384个槽分别被指派给了集群中的哪些节点。**

**2.3 记录集群所有槽的指派信息**

clusterState结构中的slots数组记录了集群中所有16384个槽的指派信息，此数组包含16384个项，每个项都是一个指向clusterNode结构的指针：

- 若slots[i]指针指向NULL，表示槽i尚未指派给任何节点
- 若slots[i]指针指向一个clusterNode结构，表示槽i已经指派给了clusterNode结构所代表的节点

使用clusterState.slots相较于使用clusterNode.slots来说有一点好处：检查某个槽是由哪个节点处理时无需遍历所有的clusterNode，只需看clusterState.slots[i]指向的clusterNode即可。

其实两个数组的特点决定了用途不同，当进行“传播节点的槽指派信息”时，要使用clusterNode.slots，这样不用遍历所有的clusterState.slots；而在查找某个槽是由哪个节点处理时，只需遍历clusterState.slots即可。

**2.4 CLUSTER ADDSLOTS命令实现**

此命令的实现就是对上面两个结构**clusterState****.slots**和**clusterNode****.slots**进行相应的更新即可，一个是更改slot[i]的指针指向指定的clusterNode，一个是更新相应的下标值为1。最后在CLUSTER ADDSLOTS命令执行完后，节点会通过发送消息告知集群中的其他节点，自己目前正在负责处理哪些槽。

**3. 在集群中执行命令**

**当客户端向节点发送与数据库有关的命令时，接收命令的节点会计算出命令要处理的数据键属于哪个槽，并检查这个槽是否指派给了自己：若恰好指派给了自己则直接执行此命令，否则会向客户端返回一个MOVED错误，指引客户端转向正确的节点，并再次发送之前想要执行的命令。**

**3.1 计算键属于哪个槽**

节点使用以下算法来计算给定键key属于哪个槽：

```
def slot_number(key):
    return CRC16(key) & 16383
```

其中CRC16(key)语句用于计算键key的CRC-16校验和，而& 16383语句用于计算出一个介于0至16383之间的整数作为键key的槽号。使用**CLUSTER KEYSLOT <key>**命令可查看一个给定键属于哪个槽。

**3.2 判断槽是否由当前节点负责处理**

通过上面方法计算出槽I后，节点就会检查自己在clusterState.slots数组中的项i，判断键所在的槽是否由自己负责：若slots[i]等于myself，则是自己并执行命令；否则根据slots[i]指向的clusterNode结构记录的节点IP和端口号，向客户端返回MOVED错误，指引客户端转向至正在处理槽i的节点。

**3.3 MOVED 错误**

MOVED错误的格式为：

```
MOVED <slot> <ip>:<port>
```

其中slot为键所在的槽，而ip和port则是负责处理槽slot的节点IP地址和端口号。当客户端接收到节点返回的MOVED错误时，客户端会根据MOVED错误中提供的IP地址和端口号，转向至负责处理槽slot的节点，并向该节点重新发送之前想要执行的命令。

**3.4 节点数据库的实现**

集群节点保存键值对和过期时间的方式与普通的Redis单机完全相同，有一个区别是节点只能使用0号数据库，而单机没有此限制。另外除了将键值对保存在数据库里外，节点还会用clusterState结构中的**slots_to_keys跳跃表**来保存槽和键的关系

slots_to_keys跳跃表中每个节点的**分值都是一个槽号**，每个节点的**成员都是一个数据库键**。当节点往数据库中添加新的键值对时，就会将这个键及对应的槽号关联到slots_to_keys跳跃表。通过在slots_to_keys跳跃表中记录各个数据库键所属的槽，节点可以很方便地对属于某个或某些槽的所有数据库键进行批量操作。

**4. 重新分片****（重要）**

Redis集群的重新分片操作可将任意数量已经指派给某个节点的槽改为指派给另一个节点，且相关槽所属的键值对也会从源节点被移动到目标节点，重新分片操作可以在线进行，且此过程中源节点和目标节点都可继续处理命令请求。

**实现原理**

此操作是由Redis的集群管理软件redis-trib负责执行的，redis-trib通过向**源节点**和**目标节点**发送命令来进行重新分片操作。redis-slot对集群中的**单个槽slot**进行重新分片的步骤如下：

1. redis-trib对目标节点和源节点分别发送CLUSTER SETSLOT <slot> IMPORTING / MIGRATING <source_id> / <target_id>命令，让两者做好导入准备。
2. redis-trib向源节点发送**CLUSTER GETKEYSINSLOT <slot> <count>**命令，返回并得到最多count个属于槽slot的键值对的键名。
3. 对于上一步获得的每个键名，redis-trib向源节点发送一个MIGRATE <target_ip> <target_port> <key_name> 0 <time_out>命令，将被选中的键原子地从源节点迁移至目标节点。
4. 重复上述2、3两步，直到所有**属于槽slot**的键值对都被迁移至目标节点为止。

![img](https://note.youdao.com/yws/public/resource/cde132b80b71352363b55f0fc83cd5ff/xmlnote/DC4D532CC7CC4C52A75907D8F551B1DC/561D2FC6C23949749D434305DA667167/5361)

## 5. ASK错误

重新分片时，若被迁移槽的一部分键值对保存在源节点里，而另外一部分键值对保存在目标节点里。当客户端向源节点发送一个与数据库键有关的命令时，若此键恰好属于正在被迁移的槽时：

- 源节点会现在自己的数据库里查找指定键，找到则直接执行客户端发送的命令。
- 没找到则这个键有可能已被迁移到了目标节点，会向客户端返回一个ASK错误，指引客户端向正在导入槽的目标节点，并再次发送之前想要执行的命令。

### 5.1 CLUSTER SETSLOT IMPORTING / MIGRATING命令实现

这两个命令分别存在了clusterState结构的**importing_slots_from**数组和**migrating_slots_to**数组。

- importing_slots_from数组记录当前节点正在从其他节点导入的槽。若下标i的值不为NULL而是指向一个clusterNode结构，则表示当前节点正在从clusterNode所代表的节点导入槽i.
- migrating_slots_to数组记录当前节点正在迁移至其他节点的槽。若下标i的值不为NULL而是指向一个clusterNode结构，则表示当前节点正在将槽i迁移至clusterNode所代表的节点。

### 5.2 ASK错误

若一个节点接受度奥关于key键的命令请求后，没有在自己数据库中找到键key，则检查自己的clusterState.migrating_slots_to[i]，看键key所属的槽i是否正在迁移。若是则会向客户端发送一个ASK错误，引导其去另一个节点查找key。

客户端接收到**ASK错误**后根据提供的IP和端口号，转向正在导入槽的目标节点，然后首先向目标节点发送一个**ASKING**命令，之后再重新发送原本想要执行的命令。

**5.3 ASKING命令**

ASKING命令唯一要做的就是打开发送该命令的客户端的**REDIS_ASKING**标识，因为一般情况下若槽i不在本节点，那它会向客户端返回一个MOVED错误；但是①若节点的clusterState.importing_slots_from[i]显示本节点正在导入槽i，②且发送命令的客户端有**REDIS_ASKING**标识，则节点将破例执行这个关于槽i的命令一次。

**5.3 ASK错误和MOVED错误的区别**

两者都会导致客户端转向，区别在于：

- MOVED错误代表槽的负责权已由一个节点转移到了另一个节点。客户端收到此错误后**每次遇到槽i的命令请求时**可直接根据命令的参数将命令发送到指定节点，因为此指定节点是目前负责槽i的节点。
- ASK错误只是两个节点在迁移槽的过程中使用的一种**临时措施**。客户端收到关于槽i的ASK错误后，客户端只会**在接下来的一次命令请求中**将关于槽i的命令请求发送至ASK错误所指示的节点。但这种转向不会对客户端今后发送关于槽i的命令请求产生任何影响，客户端仍会将关于槽i的命令请求发送至目前负责处理槽i的节点。

根本原因在于一个槽对应多个键，可能某个键处在槽i中且正在迁移，就会返回ASK命令，但如果所有的键都迁移了，相当于槽i现在根本不属于此节点负责了，那么就返回MOVED错误。

## 6. 复制与故障转移（重要）

Redis中节点分为主节点和从节点：**主节点用于处理槽，从节点用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求**。也就是主节点用来处理主要命令，而从节点只是复制主节点以防止下线（当然也可以分担一些读请求）。

### 6.1 设置从节点

向一个节点发送命令：CLUSTER REPLICATE <node_ip>可让接收命令的节点称为node_id所指定节点的从节点，且开始对主节点进行复制。其中会对内部的一系变量和状态进行改变。

一个节点成为从节点，并开始复制某个主节点这一信息会通过消息发送给集群中的其他节点，最终集群中的所有节点都会知道某个从节点正在复制某个主节点。而其他的所有节点会改变自己的内部结构来记录这一信息。

### 6.2 故障检测

集群中的每个节点都会定期地向集群中其他节点发送PING消息来检测对方是否在线。若接受PING消息的节点未在规定时间内返回PONG消息，那发送PING消息的节点会将它标记为**疑似下线（PFAIL）**。

集群中的各个节点会通过互相发消息的方式交换集群中各个节点的状态，例如某个节点是处于在线、疑似下线、已下线。若一个集群里，半数以上负责处理槽的主节点都将某个主节点X报告为疑似下线，那次处节点将被标记为已下线（FAIL），将主节点X标记为已下线的节点会向集群广播一条关于主节点X的FAIL消息，其他收到此消息的节点会将节点X标记为已下线。

### 6.3 故障转移

当一个从节点发现自己正在复制的主节点进入已下线状态，从节点将开始对下线主节点进行故障转移，以下是其执行步骤：

1. 复制下线主节点的所有从节点里面，会有一个从节点被选中。
2. 被选中的从节点执行SLAVE no one命令，成为新的主节点。
3. **新主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。**
4. 新主节点向集群广播一条PONG消息，此消息可让集群中其他节点立即知道此节点已变为主节点，且由它来处理原来已下线节点负责处理的槽。
5. 新的主节点开始接受和自己负责处理的槽有关的命令请求，故障转移完成。

### 6.4 选举新的主节点（重要）

新的主节点是通过选举产生的：

1. 集群的配置纪元是一个自增计数器，初始值为0
2. 当集群里某个节点开始一次故障转移操作时，集群配置纪元全部加一
3. 对于每个配置纪元，集群里每个负责处理槽的主节点都有一次投票机会，而第一个向主节点要求投票的从节点将获得主节点的投票
4. 当从节点发现自己正在复制的主节点进入已下线状态，从节点会向集群广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，要求所有收到这条消息、并且具有投票权的主节点向这个从节点投票。
5. 若一个主节点具有投票权（正在负责处理槽），且此节点尚未投票给其他从节点，那它会向要求投票的从节点返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示它支持此节点成为新的主节点。
6. 每个参与选举的从节点都会接收到CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，并根据自己收到了多少消息来统计获得了多少主节点支持。
7. 假设集群中有个具有投票权的主节点，那么当一个从节点收集到大于等于N / 2 + 1张支持票时，此从节点就会当选为新的主节点
8. 因为在每个配置基于案例每个具有投票权的主节点只能投一次票，所以若有N个主节点进行投票，那么只会有一个节点的票数大于等于N / 2 + 1
9. 若在一个配置纪元里没有从节点能收集到足够多的的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。

## 7. 消息

节点发送的消息主要有以下五种：

- MEET消息：当发送者接收到客户端发送的CLUSTER MEET命令时，发送者会向接收者发送MEET消息，请求接收者加入到发送者当前所处的集群里面。
- PING消息：集群里每个节点默认每秒从已知节点列表中随机选出五个节点，然后对这
- PONG消息：
- FAIL消息
- PUBLISH消息：