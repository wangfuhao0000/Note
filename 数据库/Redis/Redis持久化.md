## RDB持久化

**1. RDB文件的创建与载入**

有两个命令可用于生成RDB文件，一个是**SAVE**，另一个是**BGSAVE。**

- **SAVE****命令**：会阻塞Redis服务进程，直到RDB文件创建完毕为止。服务器阻塞期间，服务器不能处理任何命令请求。
- **BGSAVE****命令**：它会派生出一个子进程，然后由子进程创建RDB文件，服务器进程（父进程）继续处理命令请求。

和创建RDB文件不同，RDB文件的**载入工作**是在服务器启动时自动执行的，所以Redis没有载入RDB文件的命令，只要在启动时检测到RDB文件存在就自动载入。

要注意到，因为AOF文件的更新频率通常比RDB文件的更新频率高，所以：

- 若数据库开启了AOF持久化功能，则服务器优先使用AOF文件还原数据库。
- 只有AOF持久化功能关闭时，数据库才会使用RDB文件来还原数据库。

**1.1 SAVE命令执行时的服务器状态**

执行**SAVE**命令时Redis数据库会被阻塞，此时客户端发送的所有命令都会被阻塞（拒绝处理），直到**SAVE**命令执行完毕才会接受新的命令并处理。

**1.2 BGSAVE命令执行时的服务器状态**

**BGSAVE**命令的保存工作是由子进程执行，所以创建RDB文件过程中Redis服务器仍可继续处理客户端命令请求。但命令执行过程中，服务器处理**SAVE**、**BGSAVE**、**BGREWRITEAOF**三个命令的方式和平时不太相同。

- **SAVE**命令会直接被服务器拒绝，为了避免父进程（服务器进程）和子进程同时执行两个rdbSave调用，防止产生竞争条件。
- **BGSAVE**命令会直接被服务器拒绝，同样也是防止产生竞争条件。
- **BGREWRITEAOF**和**BGSAVE**不能同时执行：若**BGSAVE**正在执行，则**BGREWRITEAOF**会被延迟到**BGSAVE**命令执行完之后执行；若**BGREWRITEAOF**正在执行，则**BGSAVE**会被服务器拒绝。

**1.3 RDB文件载入时的服务器状态**

服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。

**2. 自动间隔性保存**

因为**BGSAVE**命令可在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置的save选项，让服务器每个一段时间自动执行一次**BGSAVE**命令。可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行**BGSAVE**命令。例如：

```
save 900 1   //服务器在900秒内对数据库进行了至少1次修改
save 300 10   //服务器在300秒内对数据库进行了至少10次修改
save 60 10000   //服务器在60秒内对数据库进行了至少10000次修改
```

**2.1 设置保存条件**

通过save选项设置的条件会赋给服务器状态的saveparams属性，saveparams属性是个数组，其中每个元素都是一个saveparam结构，此结构保存了**一个秒数**和**一个修改数**，如下：

```
struct redisServer {
    //记录保存条件的数组
    struct saveparam *saveparams;
    long long dirty;   //修改计数器
    time_t lastsave;   //上次执行保存的时间
}

struct saveparam {
    time_t seconds;   //秒数
    int change;   //修改数
}
```

**2.2 dirty计数器和lastsave属性**

除了saveparams数组外，服务器还维持一个**dirty计数器**，以及一个**lastsave属性**：

- dirty计数器记录距离上次成功执行**SAVE**命令或**BGSAVE**命令后，服务器对数据库状态（所有数据库）进行了多少次修改（写入、删除、更新）。
- lastsave属性是个UNIX时间戳，记录服务器上一次成功执行**SAVE**命令或**BGSAVE**命令的时间。

**2.3 检查保存条件是否满足**

Redis服务器周期性操作函数**serverCron**默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的工作之一就是检查save选项所设置的保存条件是否已经满足（saveparams数组内容），只要有任意一个条件被满足则执行**BGSAVE**命令。

——————————————————————————————————————————————————————————————

**3. RDB文件结构**

下面看一下RDB文件结构和意义。下图展示了一个完整RDB文件包含的各个部分：

| REDIS | db_version | **databases** | EOF  | check_num |
| ----- | ---------- | ------------- | ---- | --------- |
|       |            |               |      |           |

其中REDIS是个字符串代表文件开始；db_version长度为4字节，是一个字符串表示的整数来记录文件版本号；databases部分包含另个或任意多个数据库及里面的键值对数据；EOF常量长度为1字节，标志RDB文件结束；check_num是个8字节无符号整数，用于校验RDB文件内容是否出错或损坏。

**3.1 databases部分**

这部分可包括任意多个非空数据库；每个数据库都包括三个部分：

- **SELECTDB：**常量为1字节，遇到它表明接下来要读的是个**数据库号码**
- **db_number：**数据库号码，遇到它服务器调用**SELECT**命令进行数据库切换
- **key_value_paires**：保存数据库中所有键值对数据，若有过期时间则也保存过期时间

| SELECTDB | db_number | key_value_pairs |
| -------- | --------- | --------------- |
|          |           |                 |

| REDIS | db_version | SELECTDB | 0    | pairs | SELECTDB | 3    | pairs | EOF  | check_num |
| ----- | ---------- | -------- | ---- | ----- | -------- | ---- | ----- | ---- | --------- |
|       |            |          |      |       |          |      |       |      |           |

**3.2 key_value_pairs部分**

RDB文件中每个key_value_pairs部分都保存一个或以上数量的键值对，若键值对带有**过期时间**的话也会保存在这里面。带过期时间的键值对在RDB文件包括五个部分：

- **EXPIRETIME_MS**：常量1字节，告知读入程序接下来要读的是个过期时间
- **ms：**8字节长带符号整数，记录一个以毫秒为单位的UNIX时间戳
- **TYPE：**记录value的类型，九种之一
- **key：**总是个字符串对象
- **value：**根据TYPE类型不同和保存内容长度不同，保存value的结构和长度也会有所不同。

| EXPIRETIME_MS | 1388556000000 | REDIS_RDB_TYPE_SET | key  | value |
| ------------- | ------------- | ------------------ | ---- | ----- |
|               |               |                    |      |       |

**3.3 value的编码**

RDB文件中每个value部分都保存了一个值对象，每个值对象的类型都由与之对应的TYPE记录。



## AOF持久化

在Redis中，用户可通过**SLAVEOF**命令或设置**slaveof**选项让一个服务器去复制另一个服务器，我们称被复制的为**主服务器**，而对主服务器进行复制的服务器则被称为**从服务器**。

**1. 旧版复制功能的实现**

Redis的复制功能分为**同步**和**命令传播**：

- **同步**：将从服务器的数据库状态更新至主服务器当前所处的服务器状态
- **命令传播**：用于在主服务器的数据库状态被修改导致从服务器数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。

**1.1 同步**

当客户端向服务器端发送**SLAVEOF**命令时，从服务器先要执行同步操作，将从服务器的数据库状态更新至主服务器当前所处的数据库状态，此同步过程通过向主服务器发送**SYNC**命令完成：

1. 从服务器向主服务器发送**SYNC**命令
2. 收到**SYNC**命令的主服务器执行**BGSAVE**命令，在后台生成一个**RDB文件**，并使用一个**缓冲区**记录从现在开始执行的所有写命令。
3. 主服务器执行完BGSAVE命令后，将生成的RDB文件发送给从服务器，从服务器接受并载入此RDB文件，将自己数据库状态更新到主服务器**执行BGSAVE命令时**的状态。
4. 主服务器将记录在缓冲区里的所有写命令发送给从服务器，从服务器执行这些写命令，将自己状态更新到主服务器当前状态。

**总之就是主服务器会使用****BGSAVE****生成RDB文件，并在生成的过程中记录下所有的写命令，最后将RDB文件和写命令发送给客户端。**

**1.2 命令传播**

就是在主服务器自己执行写命令造成主从服务器数据库状态不一致，则将这条写命令也发送给从服务器执行，从服务器执行接收到的命令后两者的数据库状态再次回到一致状态。

**2. 旧版复制功能的缺陷**

Redis2.8以前，从服务器对主服务器的复制可分为下面两种情况：

- **初次复制**：从服务器以前没复制过任何主服务器，或从服务器现在要复制的主服务器和上一次不是一个。
- **断线后重复制**：处于命令传播阶段的主从服务器因为网络原因中断了复制，但从服务器通过自动重连连接上了主服务器，并继续复制主服务器。

对于初次复制的情况，旧版能很好胜任；而对于断线后重连再复制，因为断线后从服务器并不知道自己原来是在哪个时刻和主服务器一致，所以需要重新发送**SYNC**命令来**完整的重新复制**一遍主服务器，也就相当于初次复制，因而效率比较低。

SYNC命令是个很耗资源的操作，主要执行以下动作：

1. 主服务器需执行**BGSAVE**命令来生成RDB文件，这个过程会耗费主服务器大量的CPU、内存和磁盘I/O资源。
2. 主服务器需将生成的RDB文件发给从服务器，耗费大量网络资源。
3. 接收到RDB文件后，从服务器需载入RDB文件，造成阻塞而无法响应命令请求。

**3. 新版复制功能的实现**

Redis2.8以后使用**PSYNC**命令代替**SYNC**命令来执行复制时的同步操作，此命令具有**完整重同步**和**部分重同步**两种模式：

- **完整重同步**：用于处理初次复制情况，和**SYNC**命令执行步骤基本一样。
- **部分重同步**：当从服务器断线后重新连接主服务器时，主服务器可将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只需接受并执行这些命令就可和主服务器保持同步。

所以能看出区别来，执行**SYNC**命令需生成、传送和载入整个RDB文件，而部分重同步只需将从服务器缺少的写命令发送给从服务器执行就可以了。

**4. 部分重同步的实现**

部分重同步功能由以下三个部分构成：

- 主服务器的**复制偏移量**和从服务器的复制偏移量
- 主服务器的**复制积压缓冲区**
- 服务器的**运行ID**

**4.1 复制偏移量**

执行复制的双方——主服务器和从服务器会分别维护一个复制偏移量：

- 主服务器每次向从服务器发送N个字节数据时，其复制偏移量就加上N
- 从服务器每次从主服务器接收到N个字节数据时，其复制偏移量就加上N

通过主、从服务器的复制偏移量，程序很容易判断出两者的数据库状态是否一致，若两个偏移量相同则一致，否则不一致。

**4.2 复制积压缓冲区**

它是一个由主服务器维护的**固定长度、先进先出队列**，默认大小为1MB，可以根据需要和场景调整此缓冲区大小。

当主服务器进行命令传播时，他不仅会将写命令发送给所有从服务器，还会将**写命令**入队到复制积压缓冲区里。因此主服务器的复制积压缓冲区里会保存一部分最近传播的写命令，且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量。

| 偏移量 | 10087 | 10088 | 10089 | 10090 | 10091 | 10092 |
| ------ | ----- | ----- | ----- | ----- | ----- | ----- |
| 字节值 | '*'   | 3     | '\r'  | '\n'  | '$'   | 3     |

当从服务器重连上主服务器时，从服务器通过**PSYNC**命令将自己的复制偏移量offset发给主服务器，主服务器根据此复制偏移量来决定对从服务器执行何种同步操作：

- 若offset偏移量之后的数据仍存在于复制积压缓冲区里，则主服务器对从服务器执行部分重同步操作
- 相反offset偏移量之后的数据已不存在于复制积压缓冲区，那主服务器将对从服务器执行完整重同步操作（因为这是个固定长度队列，说明已经执行了很多命令，offset之后的有些命令已经不存在缓冲区里了，所以需要完整重同步）

**4.3 服务器运行ID**

这个字段的目的就是判断从服务器要重连的主服务器和上一次连接的是不是同一个。

- 每个Redis服务器不论主从都会有自己的运行ID
- 运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成。

当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传给从服务器，从服务器将这个运行ID保存起来。当从服务器断线并重连上一个主服务器时，会将之前保存的主服务器ID发送给它：

- 若两个此ID和现在的主服务器ID一致，则主服务器可尝试执行部分重同步操作。
- 否则主服务器将对从服务器执行完整重同步操作。

**5. PSYNC命令的实现**

此命令的调用方法有两种：

- 若从服务器以前未复制过任何主服务器或执行过**SLAVEOF** **no one**命令，则从服务器在开始一次新的复制时向主服务器发送PSYNC ？ -l命令，主动请求主服务器进行**完整重同步**。
- 相反从服务器已经复制过某个主服务器，则从服务器在开始一次新的复制时将向主服务器发送**PSYNC** **<runid> <offset>**命令：runid是上次复制的主服务器运行ID，offset是从服务器当前的偏移量，接受到这个命令的主服务器会根据这两个参数判断应执行哪种同步操作。

根据情况，主服务器接收到PSYNC命令后会返回以下三种之一：

- 若主服务器返回 +**FULLRESYNC** **<runid> <offset>**，表示主服务器要与从服务器执行完整重同步操作：其中runid是这个主服务器运行ID，从服务器会将它保存起来用于下一次发送PSYNC命令，而offset是主服务器当前的复制偏移量，从服务器将它作为自己的初始化偏移量。
- 若主服务器返回+ **CONTINUE**回复，则表示执行部分重同步操作，从服务器只需等着主服务器将自己缺少的那部分数据发送过来。
- 若主服务器返回 **-ERR**回复，表示主服务器版本低于Redis2.8，识别不了**PSYNC**命令，从服务器将会向主服务器发送**SYNC**命令，并执行完整同步操作。

**6. 复制的实现**

通过向主服务器发送SALVEOF命令，可以让一个从服务器去复制一个主服务器：

```
SALVEOF <master_ip> <master_port>
```

**6.1 步骤1：设置主服务器的地址和端口**

当客户端向从数据库发送下面**SALVEOF**命令

```
127.0.0.1:12345> SALVEOF 127.0.0.1 6379
```

从服务器首先要将客户端给定的**主服务器**IP地址127.0.0.1和端口6379保存到服务器状态的**masterhost**属性和**masterport**属性里。**SALVEOF**命令是一个**异步命令**，完成两个属性的设置后从服务器将向客户端返回OK表示复制指令已被接受，而实际复制工作是在OK返回后才开始执行。

**6.2 步骤2：建立套接字连接**

在**SLAVEOF**命令执行后，从服务器将根据命令所设置的IP地址和端口，创建连向主服务器的套接字连接。若连接成功，则从服务器将为这个套接字关联一个专门用于处理复制工作的**文件事件处理器**，它负责后续的复制工作，比如接受RDB文件、接收主服务器传播来的写命令等。

而主服务器接受从服务器的套接字连接后，将为该套接字创建相应的**客户端状态**。并将从服务器看做是一个连接到主服务器的客户端来对待。

**6.3 步骤3：发送PING命令**

从服务器成为主服务器客户端后，首先会向主服务器发送一个**PING**命令，它有两个作用：

- 虽然双方建立了套接字连接，但还未进行通信，通过发送**PING**命令可检查套接字的读写状态是否正常。
- 检查主服务器能否正常处理命令请求。

从服务器发送**PING**命令后会遇到下面三种情况之一：

- 若主服务器发送了命令回复，但从服务器不能在规定时间内读取回复内容，说明两者之间网络连接状态不好。此时从服务器要断开并重新创建连向主服务器的套接字
- 若主服务器返回一个错误，表示主服务器暂时无法处理这些请求，此时从服务器要断开并重新创建连向主服务器的套接字
- 若从服务器读取到“**PONG**”回复，表示主从服务器之间的网络连接状态正常，可继续复制工作。

**6.4 步骤4：身份验证**

从服务器收到主服务器返回的“PONG”回复后，下一步就是决定是否进行身份验证，它是通过从服务器的masterauth选项来决定。若从服务器设置了此选项，则会向主服务器发送**ATUTH masterauth**命令，验证阶段可能遇到的情况有以下几种：

- 若主服务器未设置requirepass选项，且从服务器也未设置，则主服务器执行从服务器发送的命令，复制工作可继续执行。
- 若从服务器通过**AUTH**命令发送的密码和主服务器requirepass选项设置的密码相同，则复制工作可继续；不相同，主服务器返回一个invalid password错误。
- 若主服务器设置了requirepass选项，从服务器却未设置masterauth选项，则主服务器返回一个NOAUTH错误；另一方面若主服务器未设置requirepass选项，而从服务器设置了masterauth选项，那么主服务器将返回一个no password is set错误。

所有错误情况都会令服务器中止目前的复制工作，并从创建套接字开始重新执行复制，直至身份验证通过，或从服务器放弃复制。

**6.5 步骤5：发送端口信息**

身份验证步骤后，从服务器将执行命令**REPLCONF listening-port <port-number>**，向主服务器发送从服务器的监听端口号。主服务器收到这个命令后，会将端口记录在从服务器对应的客户端状态的**slave_listening_port**属性中。**slave_listening_port**属性目前的唯一作用就是在主服务器执行INFO_replication命令时打印出服务器的端口号。

**6.6 步骤6：同步**

从服务器向主服务器发送**PSYNC**命令，执行同步操作，将自己的数据库状态更新至主数据库当前所处的状态。要注意在同步之前只有从服务器是主服务器的客户端，但在执行同步操作后，主服务器也会成为从服务器的客户端，因为执行两种的任一种同步操作都需要主服务器向从服务器发送写命令，完整——缓冲区、部分——复制积压缓冲区。

**6.7 步骤7：命令传播**

完成了同步后，主从服务器就会进入命令传播阶段。这是主服务器只要一直将自己执行的写命令发送给从服务器，而主服务器只要一直接受并执行主服务器发送的写命令，就可保证主从服务器一致。

**7. 心跳检测**

在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令：

**REPLCONF ACK <replication_offset>**

其中**replication_offset**是从服务器当前的复制偏移量。发送**REPLCONF ACK**命令对于主从服务器有三个作用：

- 检测主从服务器的网络连接状态
- 辅助实现min-slaves选项
- 检测命令丢失

**7.1 检测主从服务器连接状态**

主从服务器可通过发送和接受**REPLCONF ACK**命令来检查两者之间的网络连接是否正常：若主服务器超过一秒没有接收到从服务器发来的**REPLCONF ACK**命令，那么主服务器就知道主从服务器之间的连接出问题了。

可通过向主服务器发送**INFO replication**命令，查看lag一栏中所有从服务器最后一次向主服务器发送**REPLCONF ACK**命令距离现在过了多少秒。

**7.2 辅助实现min-slaves配置选项**

Redis的min-slaves-to-write和min-slaves-max-lag两个选项可防止主服务器在不安全的情况下执行写命令。例如我们向主服务器提供以下设置：

- min-slaves-to-write 3
- min-slaves-max-lag 10

那么在从服务器的数量少于3个或者3个从服务器的延迟（lag）都大于等于10秒时，主服务器将拒绝执行写命令。

**7.3 检测命令丢失**

若因网络故障，主服务器传播给从服务器的**写命令丢失**，那当从服务器向主服务器发送**REPLCONF ACK**命令时，主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器会根据从服务器发送的偏移量从自己的复制积压缓冲区里找到从服务器缺失的数据，并将这些数据重新发送给从服务器。

注意主服务器向从服务器补发缺失数据这一操作原理和部分重同步操作原理非常相似，区别在于：补发缺失数据操作发生在主从服务器**未断线**情况下，而部分重同步操作则是主从服务器**断线重连**后的操作。