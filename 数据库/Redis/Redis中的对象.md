**1. 对象的基本概念**

redis使用对象来表示数据库中的键和值，所以每次创建一个新的键值对时至少创建了两个对象：键对象和值对象。redis中的每个对象都是一个redisObject结构，该结构中有三个属性：type属性、encoding属性和ptr属性。

```
typedef struct redisObject {
    unsigned type:4;  //对象类型，五种对象之一
    unsigned encoding:4;   //对象编码，代表了底层实现
    void *ptr;   //指向底层实现数据结构的指针
} robj;
```

**1.1 类型（type属性）**

type属性记录了对象类型，可以是一下的五种之一。要知道我们说一个键为某种键（如列表键）指的是它对应的**值**是一个列表对象，可以使用**TYPE key**命令查看键的类型。其中集合对象表示的是内部没有重复元素的对象

| **类型常量** | **对象的名称** |
| ------------ | -------------- |
| REDIS_STRING | 字符串对象     |
| REDIS_LIST   | 列表对象       |
| REDIS_HASH   | 哈希对象       |
| REDIS_SET    | 集合对象       |
| REDIS_ZSET   | 有序集合对象   |

**1.2 编码和底层实现（encoding属性）**

ptr指向对象的底层实现是由encoding属性决定的，可以使用**OBJECT ENCODING**命令查看数据库键的值对象编码。每一个类型的对象都有两种及以上实现方式，详细如下表：

| 类型         | 编码                      | 对象                         |
| ------------ | ------------------------- | ---------------------------- |
| REDIS_STRING | REDIS_ENCODING_INT        | 用整数值实现的字符串对象     |
| REDIS_STRING | REDIS_ENCODING_EMBSTR     | 用embstr编码的sds实现        |
| REDIS_STRING | REDIS_ENCODING_RAW        | 用原生的sds实现              |
| REDIS_LIST   | REDIS_ENCODING_ZIPLIST    | 用压缩列表实现的列表对象     |
| REDIS_LIST   | REDIS_ENCODING_LINKEDLIST | 用双端链表实现               |
| REDIS_HASH   | REDIS_ENCODING_ZIPLIST    | 用压缩列表实现的哈希对象     |
| REDIS_HASH   | REDIS_ENCODING_HT         | 用字典实现                   |
| REDIS_SET    | REDIS_ENCODING_INTSET     | 用整数集合实现的集合对象     |
| REDIS_SET    | REDIS_ENCODING_HT         | 用字典实现                   |
| REDIS_ZSET   | REDIS_ENCODING_ZIPLIST    | 用压缩列表实现的有序集合对象 |
| REDIS_ZSET   | REDIS_ENCODING_SKIPLIST   | 用跳跃表和字典实现           |

**2. 字符串对象**

**2.1 介绍**

字符串对象编码可以是int、raw或者embstr，这取决于对象的特点。

- 字符串对象保存的是个整数值且可以用long类型表示，则其编码为"int"。
- 字符串对象保存的是个字符串值，且长度大于39字节，则编码为"raw"，即原生的sds。
- 字符串对象保存的是个字符串值，且长度小于等于39字节，则编码为"embstr"，即embstr编码的sds。

这里说一下**embstr编码**。他其实和raw类似，也是用redisObject结构和sdshdr结构表示字符串对象，但raw编码会调用两次内存分配来分别创建redisObject和sdshdr，但embstr只需调用一次来分配一块连续的空间，此空间内一次包含redisObject和sdshdr两个结构。它的优点是：减少了内存分配和内存释放的次数、连续内存保证能更好地利用缓存带来的优势。

| redisObject | sdshdr   |      |      |      |      |      |
| ----------- | -------- | ---- | ---- | ---- | ---- | ---- |
| type        | encoding | ptr  | ...  | free | len  | buf  |

最后要说的是，如果有一个浮点数（和上面的整数区分开），它也是作为字符串值来保存的。当要对它进行运算时，会按照取出、转为浮点数、运算、转为字符串、存回的顺序执行命令。

**2.2 编码转换**

**只有int和embstr编码的对象会转换，转换为raw编码。**

- 对int编码的字符串对象执行一些命令（例如APPEND），使其存储的不再是整数值而是个字符串，那么编码将由int变为raw。
- embstr编码的字符串没有修改程序，是只读的，所以对它进行任何修改命令（例如APPEND）都会使其编码由embstr变为raw

**3. 列表对象**

**3.1 介绍**

列表对象编码可以是ziplist或linkedlist。

ziplist编码的列表对象使用**压缩列表**作为底层实现，每个压缩列表节点（entry）都存放一个列表元素。

linkedlist编码的列表对象使用**双端链表**作为底层实现，每个双端链表节点（node）都保存一个字符串对象，每个对象里面存着一个列表元素。这是与ziplist不同的地方

**3.2 编码转换**

列表对象同时满足以下两个条件时，列表对象使用ziplist编码，否则使用linkedlist编码：

- 列表对象保存的所有字符串**元素长度**都小于64字节。
- 列表对象保存的**元素数量**小于512个。

当然这两个值的上限是可以修改的。

**4. 哈希对象**

**4.1 介绍**

哈希对象的编码可以是ziplist或者hashtable。

ziplist作为底层实现时，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后将保存了值的压缩列表节点推入到压缩列表表尾。因此

- 保存同一键值对的两个节点总是紧挨在一起，键在前、值在后。
- 先添加的键值对会在压缩列表表头方向，后来的在表尾方向。

hashtable作为底层实现时，哈希对象中的每个键值对都用一个字典键值对来保存：

- 字典的键是个字符串对象，保存键值对的键
- 字典的值是个字符串对象，保存键值对的值

**4.2 编码转换**

哈希对象同时满足以下两个条件时，哈希对象使用ziplist编码，否则使用hashtable编码：

- 哈希对象保存的所有键值对的**键、值字符串长度**都小于64字节；
- 哈希对象保存的**键值对数量**小于512个；

当然它们的上限也是可以修改的。

**5. 集合对象**

**5.1 介绍**

集合对象的编码可以是intset或者hashtable

intset编码的集合对象使用**整数集合**作为底层实现，集合对象包含的所有元素保存在整数集合里。

hashtable编码的集合对象使用**字典**作为底层实现，字典的每个键都是一个**字符串对象**，此对象包含了集合元素，字典的值全部设为**NULL**。

**5.2 编码转换**

当集合对象同时满足以下两个条件时，对象使用intset编码，否则使用hashtable编码：

- 集合对象保存的所有元素都是整数值
- 集合对象保存的元素数量不超过512个（上限可修改）

**6. 有序集合对象**

**6.1 介绍**

有序集合的编码可以是ziplist或者skiplist。

ziplist编码的有序集合使用**压缩列表**作为底层实现，每个集合元素使用**两个**紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member）、第二个保存元素的分值（score）。压缩列表内的集合元素按分值**从小到大**进行排序。

skiplist编码的有序集合使用**zset**结构作为底层实现，一个zset结构包含一个**字典**和一个**跳跃表**，

```
typedef struct zset {
    zskiplist *zsl;
    dict *dict;
} zset;
```

zsl跳跃表按分值**从小到大**保存了所有集合元素，每个跳跃表节点保存一个集合元素：跳跃表节点的object属性保存元素成员，score属性保存元素的分值。通过这个跳跃表，就能实现对有序集合的**范围型**操作，如ZRANK、ZRANGE等命令。

dict字典为有序集合创建了一个从成员到分值的映射，字典的每个键值对保存一个集合元素：键保存元素成员、值保存元素分支。通过这个字典，程序可以用O(1)复杂度查找**给定成员**的分值。

有序集合的每个元素中：成员是个字符串对象，分支是个double类型浮点数。虽然zset同时结构使用了两种结构实现，但是他们会通过指针**共享**相同元素的成员和分值，所以不会产生额外的内存。之所以用两种结构实现，就是因为对有序集合会执行**范围操作**和**指定操作**，以上两种结构都不能同时满足这两种操作。

**6.2 编码转换**

当有序集合对象同时满足下面两个条件是，对象使用ziplist编码，否则使用skiplist编码：

- 有序集合保存的**元素数量**小于128个；
- 有序集合保存的所有**元素成员的长度**都小于64字节

******************************************************************************************************************

**7. 类型检查与命令多态**

redis中用于操作键的命令基本分为两种类型：

一种可以对**任意类型的键**执行，如DEL命令、EXPIRE命令、REBANE命令、TYPE命令、OBJECT命令等。

另一种只能对**特定类型的键**执行，例如：

- SET、GET、APPEND、STRLEN只能对字符串键执行；
- HDEL、HSET、HGET、HLEN只能对哈希键执行；
- RPUSH、LPOP、LINSERT、LLEN只能对列表键执行；
- SADD、SPOP、SINTER、SCARD只能对集合键执行；
- ZADD、ZCARD、ZRANK、ZSCORE只能对有序集合键执行

**7.1 类型检查的实现**

redis在执行命令前是要检查键的类型是否与命令一直，类型检查是通过redisObject结构的**type属性**实现的。因为一共就物五种类型的键，所以也就不难检查。但是因为不同的键有不同的编码方式（底层实现），所以在类型检查完后还要根据值对象的编码方式，选择正确的命令实现代码来执行命令，也就是下面讲的命令多态。

**7.2 多态命令的实现**

其实多态命令的实现说到底就是调用了底层实现的函数，例如我们对一个键执行LLEN命令，那么首先要确保这个键是个列表键，然后根据列表键的值对象所使用的编码来选择正确的LLEN命令实现：

- 若对象编码是ziplist，即压缩列表，则使用ziplistLen哈数返回列表长度。
- 若对象编码是linkedlist，即双端链表，则使用listLength函数返回双端链表长度。

其实也可已将DEL、EXPIRE、TYPE等命令视为多态的，只是他们是**基于类型**的多态；而我们说的命令不同实现方式是**基于编码**的多态。

**8. 内存回收**

redis在自己的对象系统中构建了一个**引用计数技术**实现内存回收机制，通过此机制程序可以跟踪对象的引用计数信息，在适当的时候自会释放对象并回收内存。此信息由redisObject结构的**refcount属性**记录：

```
typedef struct redisObject {
    //...
    //引用计数
    int refcount;
    //...
}
```

对象的引用计数信息会随着对象的使用状态而不断变化：

- 创建一个新对象，redcount值初始化为1；
- 对象被一个新程序使用时，refcount增1；
- 对象不再被一个程序使用时，refcount减1；
- 对象refcount变为0时，对象所占内存会被释放。

**9. 对象共享**

对象的refcount除了用于实现内存回收外，还带有**对象共享**的作用。

假如键A创建了一个包含整数值100的字符串对象作为值对象，此时键B也要创建同样的对象，那么可以让键A和键B共享同一个字符串对象。此过程需要两个步骤：

1. 将数据库键的值指针指向一个现有的值对象；
2. 将被共享的值对象的refcount增一。

目前来说，redis会在初始化服务器时创建一万个字符串对象，他们包含了从0到9999的所有整数值。当服务器需要用到值为0到9999的字符串对象时，服务器会使用这些共享对象，而不是新创建对象。可以使用命令**OBJECT REFCOUNT**查看对象的引用计数。

当然这些共享对象不仅只有字符串键可以使用，那些在数据结构中嵌套了字符串对象的对象（linkedlist编码的列表对象、hashtable编码的哈希对象等）都可以使用这些共享对象。当然redis不共享包含字符串的对象，因为要共享就要判断目标键与共享的是否一致，有一个**判断**的过程，若对象很负责则判断过程很长，时间复杂度太高。

**10. 对象的空转时长**

除了前面说的type、encoding、ptr和refcount四个属性之外，redisObject结构包含的最后一个属性为**lru属性**，该属性记录了对象最后一次被命令程序访问的时间：

```
typedef struct redisObject {
    //...
    unsigned lru:22;
    //...
} robj;
```

**OBJECT IDLETIME**命令可打印出给定键的空转时长，就是将当前时间减去键的值对象的lru时间计算得出。要注意，这个命令虽然访问了此键，但是并不修改对象的lru属性。

此属性还有另一个作用，若服务器打开了maxmemory选项，且服务器回收内存的算法为**volatile-lru**或者**allkeys-lru**，那么当服务器占用内存超过maxmemory选项的上限值时，空转时长较高的那部分键会优先被服务器释放掉，从而回收内存。