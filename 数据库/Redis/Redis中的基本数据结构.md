### 1. 简单动态字符串

SDS的结构如下：

```c
struct sdshdr {
    int len;   //记录buf数组中已使用字节的数量
    int free   //记录buf数组中未使用字节的数量
    char buf[]; //字节数组，用来保存字符串
}
```

![img](https://note.youdao.com/yws/public/resource/cde132b80b71352363b55f0fc83cd5ff/xmlnote/WEB989359ecdb55c8e661410ba240f09959/564060C70249449DBC42F074A0FA2AC5/24242)

SDS存储字符串时也是以空字符结尾的，即'\0'，但它不计算在len属性中。之所以保留空字符结尾，好处就是**可以直接重用一部分C字符串函数库里的函数**。

SDS与C字符串的区别有以下几点：

- SDS可以常数复杂度获取字符串长度，因为有一个len属性
- 杜绝缓冲区溢出，因为对SDS进行修改时会有一些判断策略
- 减少修改字符串时带来的**内存重分配次数**
- **二进制安全**：C字符串不能包含空字符，而SDS没有限制。SDS以二进制方式处理buf里的数据，不会做额外操作
- 兼容部分C字符串函数，因为SDS遵循以空字符'\0'结尾的惯例

#### 减少修改字符串时带来的内存重分配次数

对于C字符串的增加或缩短，程序都总要对保存这个C字符串的数组进行一次内存重分配操作。而由于Redis对性能要求较高，所以自行实现了两种优化策略：**空间预分配、惰性空间释放**

- **空间预分配**：用于优化SDS的**增长操作**。当对SDS修改后，SDS长度将小于1MB，则会分配和len同样大小的未使用空间；若修改后SDS长度大于等于1MB，则分配1MB未使用空间。这样减少了内存的分配次数。
- **惰性空间释放**：用于优化SDS的**缩短操作**。当对SDS缩短后，程序不立即回收缩短后多出来的字节，而是使用free属性将它们的数量记录起来，等待将来使用。当然SDS提供了相应的API让我们在必要的时候真正释放SDS未使用空间，避免内存浪费。

### 2. 链表

链表节点结构、链表结构分别如下：

```c
typedef struct listNode {
    struct listNode *prev;  //前置节点
    struct listNode *next;  //后置节点
    void *value;   //节点的值
}
typedef struct list {
    listNode *head;  //表头节点
    listNode *tail;  //表尾节点
    unsigned long len;  //链表节点数
    void *(*dup)(void *ptr);  //节点值复制函数
    void (*free)(void *ptr);  //节点值释放函数
    int (*match)(void &ptr, void *key);  //节点值对比函数
} list;
```

Redis的链表实现特性可总结如下：

- **双端**：链表节点带有prev和next指针，以获得前置后后置节点
- 带表**头指针**和表**尾指针**：
- 带链表**长度计数器**：即list中的len属性
- 多态：节点使用void*指针保存节点值，且可通过dup、free、match三个属性为节点值设置类型特定函数

### 3. 字典

Redis的数据库就是使用字典作为底层实现的，字典也是哈希键的底层实现之一。它使用哈希表作为底层实现，一个哈希表里可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。

#### 3.1 字典的实现

**哈希表**

Redis字典使用的哈希表结构如下：

```c
typedef struct dictht {
    dictEntry **table;  //哈希表数组
    unsigned long size; //哈希表大小
    unsigned long sizemask; //哈希表大小掩码，用于计算索引值，size-1
    unsigned long used;  //哈希表已有节点数
} dictht;
```

table属性是个数组，每个元素是一个指向dictEntry结构的指针，每个dictEntry结构保存着一个键值对。

**哈希表节点**

使用dictEntry结构表示，其中保存着一个键值对：

```c
typedef struct dictEntry {
    void *key;  //键
    union {     //值，可以是一个指针、uint64_t整数、int64_t整数
        void *val;
        uint64_t u64;
        int64_t s64;
    } v;
    struct dictEntry *next;  //指向下一个哈希节点，形成链表
} dictEntry;
```

要注意的是，其中的值是一个union，而next属性可将多个哈希值相同的键值对连接在一起，来解决键冲突问题。

**字典**

使用dict结构表示：

```C
typedef struct dict {
    dictType *type;  //类型特定函数
    void *privdata;  //私有数据
    dictht ht[2];    //两个哈希表
    int rehashidx    //rehash索引，当rehash未进行时，值为-1
} dict;
```

其中ht属性是一个包含两个项的数组，每个项是一个dictht哈希表。一般字典只使用ht[0]哈希表，**ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。还有属性`rehashidx`，它记录了rehash目前的进度，值为-1表示未在进行rehash。**

#### 3.2 解决键冲突

Redis使用链地址法来解决键冲突，因为dictEntry节点组成的链表没有尾指针，所以为了**速度考虑**，程序总是将新节点添加到链表的**表头位置**。

#### 3.3 rehash

Redis对字典的哈希表执行rehash步骤如下：

1. 为字典的ht[1]哈希表分配空间，空间大小取决于要执行的操作和ht[0]当前包含的键值对数量（used属性）。若是扩展操作，则分配空间大小为第一个大于等于ht[0].used*2的2n次方；若是收缩操作，大小为第一个大于等于ht[0].used的2n次方。
2. 将保存在ht[0]中的所有键值对rehash到ht[1]上。
3. 当ht[0]包含的所有键值对都迁移到了ht[1]后，释放ht[0]并将ht[1]变为ht[0]，并在ht[1]上新建一个空白哈希表。

**哈希表的扩展与收缩**

下面两个条件任意一个被满足时，程序自动开始对哈希表执行扩展操作：

- 服务器没有在执行**BGSAVE**命令或**BGREWRITEAOF**命令，且哈希表负载因子大于等于1
- 服务器在执行**BGSAVE**命令或**BGREWRITEAOF**命令，哈希表负载因子大于等于5

之所以根据**BGSAVE**命令或**BGREWRITEAOF**命令是否在进行而设置不同的负载因子，是因为这两个命令执行时会创建服务器进程的子进程，而大多数操作系统都采用**写时复制技术**来优化子进程使用效率。所以在子进程存在期间，扩大负载因子，避免哈希表进行扩展操作。

另一方面，当哈希表负载因子小于0.1时，程序自动对哈希表执行收缩操作。

#### 3.4 渐进式rehash（重要）

为了避免rehash对服务器性能造成影响，服务器不是一次性将ht[0]里的所有键值对都rehash到ht[1]中，而是分多次、渐进式的将ht[0]里的键值对慢慢地rehash到ht[1]中。步骤如下：

1. 为ht[1]分配空间，字典同时持有ht[0]和ht[1]两个哈希表
2. 在字典中维持一个索引计数器变量rehashidx，将其设置为0表示rehash开始
3. 在rehash进行期间，每次对字典执行添加、删除、查找或更新时，除了完成对应操作外，还会将ht[0]哈希表**在rehashidx索引上的**所有键值对rehash到ht[1]，完成后rehashidx属性增一。
4. 随着不断进行，最终ht[0]里的所有键值对会被rehash到ht[1]。然后将rehashidx设为-1，表示rehash结束。

对于第3条中，**字典的删除、查找、更新等操作会在两个表上进行，即在ht[0]中找不到就去ht[1]中找；而添加操作一律会被保存到ht[1]里，保证了ht[0]只会减少不会增加**。

### 4. 跳跃表

跳跃表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针来快速访问节点，通常作为有序集合键的底层实现。

#### 4.1 跳跃表的实现

跳跃表节点使用结构`zskiplistNode`结构表示，跳跃表则使用`zskiplist`结构表示。

其中`zskiplist`结构如下：

```c
typedef struct zskiplist {
    struct skiplistNode *head, *tail;  //表头和表尾节点
    unsigned long length;  //表中节点数
    int level;   //表中层数最大的节点的层数，用来生成一个新节点的层数
} zskiplist;
```

而zskiplistNode结构如下：

```c
typedef struct zskiplistNode {
    struct zskiplistNode *backward;  //后退指针
    double score;   //分值
    robj *obj;   //成员对象
    struct zskiplistLevel {
        struct zskiplistNode *forward;  //前进指针
        unsigned int span;  //跨度
    } level[];  //层
} zskiplistNode;
```

- 层（level）：每个节点会有多个层，每个层有两个属性：**前进指针**和**跨度**。前进指针用于访问位于表尾方向的其他节点，而跨度记录了前进指针所指向节点和当前节点的距离。注意跨度字段的作用是用来计算排位的，访问某个节点时将途经的所有层的跨度相加就是目标节点的排位
- 后退指针：指向当前节点的前一个节点，用于从表尾向表头遍历时使用。可以做降序排列
- **分值**：保存节点的分值，跳表中节点按各自保存的分值从小到大排列
- 成员对象：节点保存的成员对象

要注意当创建一个新节点时，它的层数是随机的且位于1至32，而生成此随机数时要使用到跳表中的字段level，即表中最大的节点的层数。此过程满足**幂次定律**，即越大的数出现的概率越小。

### 5. 整数集合

它是Redis用于保存整数值的集合抽象数据结构，可以保存**int16_t、int32_t**、或者**int64_t**的整数值。它的结构如下：

```
typedef struct intset {
    uint32_t encoding;  //编码方式
    uint32_t length;    //集合包含的元素数量
    int8_t contents[];  //保存元素的数组
}
```

其中contents数组中的元素都是按值的大小从小到大有序排列，且不包含任何重复项。而且虽然声明为int8_t类型，但实际存储的元素类型取决于encoding属性的值。

#### 5.1 升级

每当我们要向集合中添加新元素，且新元素类型比整数集合现有所有元素类型都要长时，整数集合需先进行**升级**，然后才能添加新元素到集合中。升级共分为三步进行：

1. 根据新元素类型，扩展整数集合底层数组的空间大小，并为新元素分配空间
2. 将底层数组现有的**所有元素转换成与新元素相同的类型**，并在转换后将元素放到正确的位置上，继续维持数组的**有序性**
3. 将新元素添加到数组里。因为能引发升级的元素一定是比现有元素**的长度**都大，所以它总是放在数组**开头或末尾**。

升级带来的好处如下：

- 提升了灵活性
- 节约内存

#### 5.2 降级

整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。

### 6. 压缩列表

它是列表键和哈希键的底层实现之一。其中：

- 当列表键中只包含少量列表项，且每项要么是小整数、要么是短字符串，则使用压缩列表实现
- 当哈希键只包含少量键值对，且每个键值对的键和值要么是小整数、要么是短字符串，则使用压缩列表实现

#### 6.1 压缩列表组成