Redis通过`MULTI`、`EXEC`、`WATCH`等命令来实现事务功能，事务执行过程中，**服务器不会中断事务而去执行客户端命令请求，而是将事务中所有命令执行完后才去处理**。下面是一个事务执行的过程：

1. 首先以一个`MULTI`命令为开始
2. 接着将多个命令放入事务中
3. 最后由`EXEC`命令将这个事务提交给服务器执行



## 事务的实现

事务的实现主要经历下面的三个阶段：

### 事务开始

MULTI命令的执行标志着事务的开始，它可将客户端**从非事务状态切换至事务状态**，实现原理为通过在客户端状态的flag属性中打开REDIS_MULTI标识完成。 

### 命令入队

当一个客户端处于非事务状态时，服务器会立即执行客户端发送的命令；但切换到事务状态时，服务器会根据发来的命令执行不同操作：

- 若命令是`EXEC`、`DISCARD`、`WATCH`、`MULTI`四个命令之一时，服务器立即执行此命令
- 若不是上述四个命令之一，则不立即执行此命令，而是把它放入一个**事务队列**里，然后向客户端返回QUEUED回复。

其中每个客户端都有自己的事务状态，它里面包含一个**事务队列**以及一个已入队命令的**计数器**（事务队列长度）。事务队列以**先进先出**（FIFO）方式保存入队命令。

### 执行事务

当一个处于事务状态的客户端向服务器发送`EXEC`命令时，此命令立即被服务器执行。服务器遍历此客户端的事务队列，执行队列中所有命令，最后将执行命令的结果返回给客户端。



## Watch命令的实现

`WATCH`命令是一个**乐观锁**保证`EXEC`命令能否执行，它可以在`EXEC`命令执行前，监事任意数量的数据库键，并在`EXEC`命令执行时，检查被监视的键是否至少有一个已经被修改过了，**若修改过则服务器拒绝执行事务**，并向客户端返回代表事务执行失败的空回复（注意如果监视了一个能过期的键，且你已经监视了此键，那么即使键在执行`EXEC`命令时过期了，事务仍会执行。这是因为下面它的实现原理中，`watched_keys`字典中没有这个键了，自然不会检查一些标识）。

### WATCH命令监视数据库键

每个Redis数据库都保存了一个`watched_keys`字典，其中：

- 此字典的键是某个被`WATCH`命令监视的数据库键，
- 而字典的值是一个**链表**，链表中记录了所有**监视相应数据库键的客户端**。

通过watched_keys字典，服务器可清楚地知道哪些数据库键正在被监视，且是在被谁监视。

### 监控机制的触发

所有对数据库进行修改的命令在执行后都会调用`touchWatchKey`函数对`watched_keys`字典进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键，如果有则会将监视被修改键的客户端的**REDIS_DIRTY_CAS标识**打开，表示该客户端的事务安全性已经被破坏。

### 判断事务是否安全

服务器接收到客户端发送来的`EXEC`命令时，会根据这个客户端是否打开了**REDIS_DIRTY_CAS**标识来决定是否执行事务：若已经打开说明客户端所监视的键至少有一个被修改了，则拒绝执行此事务；若没有则证明事务安全，继续执行客户端提交的事务，执行完毕后所有的键变为了未监视状态。

### UNWATCH 命令

可以使用`UNWATCH`命令（不带参数）释放所有被监视的键。这一点也比较有用，假如我们`WATCH`了某个键并想要在事务内更改它，但事务过程中取出此键时不想更改它了，那么就可以使用`UNWATCH`命令释放它，相当于**本客户端不再监视这个键了**，这样其它的事务就可以更改了（当然还要保证没有别的客户端监视）。

### WATCH实现原子操作

其实原理就是我们在对某个键对应的值进行操作前，先`WATCH`一下这个键，然后开启事务进行操作。如果操作失败了则说明这期间有其它的客户端更改了这个键，我们就重新进行监视、开启事务，尝试执行等这样的操作。

```shell
WATCH mykey   # 先进行监视
val = GET mykey
val = val + 1
MULTI
SET mykey $val  # 尝试更改，执行失败说明已被其他客户端修改
EXEC
```

上午代码如果执行不成功，说明已经有其它客户端修改了，所以我们就不断的重复此过程。

### DISCARD命令

这个命令就是在事务开启后（执行`MULTI`）可以丢弃队列中的命令，并恢复到非事务状态：

```shell
> SET foo 1
OK
> MULTI
OK
> INCR foo
QUEUED
> DISCARD
OK
> GET foo
"1"
```

## 事务的ACID特性

### 原子性

对于Redis的事务功能来说，事务队列中的命令要么就全部都执行，要么就一个都不执行，因此Redis的事务具有原子性。

与传统关系型数据库不同的是，**Redis不支持事务回滚机制**。即事务队列中某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到队列中的所有命令执行完毕为止。

那为什么Redis不支持事务的回滚呢，我们从官网得到了这样的答案：

- Redis通常是在执行错误的命令（参数个数不对）或者对于某些键执行了另外的命令而出错，这种错误基本在开发测试的时候就可以检查出来，因而不太会出现在生产环境中
- Redis不支持回滚使得它的实现更加简单，且速度更加快。

### 一致性

“一致”指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据。Redis通过谨慎的错误检测和简单的设计来保证事务的一致性，下面是3个Redis事务可能出错的地方：

1. **入队错误：**若一个事务在入队命令的过程中出现了命令不存在，或者命令格式不正确等情况，那么Redis将拒绝执行这个事务。
2. **执行错误：**出现这种错误一般是入队的时候服务器发现不了，只有执行时才能发现的错误。**若执行过程中发现了错误，服务器不会中断事务的执行，而是继续执行事务中余下的其他命令**，且已执行的命令不会被出错的命令影响。
3. **服务器停机：**服务器停机并重启后，可能会是空白的、由RDB文件恢复数据库、由AOF文件恢复数据库，而他们均不会影响数据库的一致性

### 隔离性

因为Redis使用单线程方式来执行事务，且服务器保证执行事务期间不会对事务进行终端，所以Redis的事务总是以串行的方式运行，事务之间不会相互影响。