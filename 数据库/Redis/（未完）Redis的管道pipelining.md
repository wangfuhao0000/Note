Redis是基于TCP协议进行通信，因此通常一个请求通过以下步骤完成：

- 客户端发送查询请求给服务器，然后以阻塞方式从socket中读取服务器响应的数据
- 服务器处理客户端的请求，然后将回复发送给客户端

客户端和服务器通过网络连接，所以导致数据包都会耗费一段时间从客户端传到服务器，然后再从服务器返回给客户端。整个时间叫做**RTT**（Round Trip Time）。所以当一个客户端需要发送很多请求时（例如不断向一个列表list中添加数据）性能会降低。假如RTT时250毫秒，那么即使服务器每秒能处理100K个请求，但由于网络的缘故，**导致每秒最多只能处理4个请求？？**。当然对于loopback interface来说可能RTT很小，但问题并没有解决。

### Redis Pipelining

我们可以让客户端在还没有读取到前面命令请求的回复时就可以开启下一个命令请求，也就是一次性发送多个命令请求给服务器，而不等待前面命令的响应。而在读取响应的时候，也是一次性读取所有的回复。这种方式叫做pipelining，很多POP3协议实现也会使用这种方式来下载新的邮件。

>注意：当使用Pipelining批量发送命令时，服务器会强制将命令的回复进行排队，且这个过程时会耗费内存的。所以如果真的需要批量发送很多命令，最好是分批发送：例如先发送10K个命令，等待服务器响应并读取响应内容后，继续发送10K个命令。

### 不完全是RTT问题

其实流水线不只是为了解决RTT问题，主要是它能够让Redis服务器充分发挥自己的性能，即每秒尽可能多的处理命令请求。因为单纯的处理一个命令请求是很快速的，包括从内存访问对应的数据结构并进行对应的操作。但是如果需要传输则要与socket打交道，这涉及到系统调用及用户态到内核态的转换，所以耗费了一定的时间。

而一次处理多个命令时只需要一次`read()`系统调用，处理完成后再和socket打交道通过`write()`系统调用将所有的数据发送出去，减少了系统调用的次数。所以使用了流水线后，服务器每秒能处理的查询次数是几乎线性增加的，最后达到不用流水线的10倍。

### 未完