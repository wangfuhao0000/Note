在Redis中，用户可通过**SLAVEOF**命令或设置**slaveof**选项让一个服务器去复制另一个服务器，我们称被复制的为**主服务器**，而对主服务器进行复制的服务器则被称为**从服务器**。

**1. 旧版复制功能的实现**

Redis的复制功能分为**同步**和**命令传播**：

- **同步**：将从服务器的数据库状态更新至主服务器当前所处的服务器状态
- **命令传播**：用于在主服务器的数据库状态被修改导致从服务器数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。

**1.1 同步**

当客户端向服务器端发送**SLAVEOF**命令时，从服务器先要执行同步操作，将从服务器的数据库状态更新至主服务器当前所处的数据库状态，此同步过程通过向主服务器发送**SYNC**命令完成：

1. 从服务器向主服务器发送**SYNC**命令
2. 收到**SYNC**命令的主服务器执行**BGSAVE**命令，在后台生成一个**RDB文件**，并使用一个**缓冲区**记录从现在开始执行的所有写命令。
3. 主服务器执行完BGSAVE命令后，将生成的RDB文件发送给从服务器，从服务器接受并载入此RDB文件，将自己数据库状态更新到主服务器**执行BGSAVE命令时**的状态。
4. 主服务器将记录在缓冲区里的所有写命令发送给从服务器，从服务器执行这些写命令，将自己状态更新到主服务器当前状态。

**总之就是主服务器会使用****BGSAVE****生成RDB文件，并在生成的过程中记录下所有的写命令，最后将RDB文件和写命令发送给客户端。**

**1.2 命令传播**

就是在主服务器自己执行写命令造成主从服务器数据库状态不一致，则将这条写命令也发送给从服务器执行，从服务器执行接收到的命令后两者的数据库状态再次回到一致状态。

**2. 旧版复制功能的缺陷**

Redis2.8以前，从服务器对主服务器的复制可分为下面两种情况：

- **初次复制**：从服务器以前没复制过任何主服务器，或从服务器现在要复制的主服务器和上一次不是一个。
- **断线后重复制**：处于命令传播阶段的主从服务器因为网络原因中断了复制，但从服务器通过自动重连连接上了主服务器，并继续复制主服务器。

对于初次复制的情况，旧版能很好胜任；而对于断线后重连再复制，因为断线后从服务器并不知道自己原来是在哪个时刻和主服务器一致，所以需要重新发送**SYNC**命令来**完整的重新复制**一遍主服务器，也就相当于初次复制，因而效率比较低。

SYNC命令是个很耗资源的操作，主要执行以下动作：

1. 主服务器需执行**BGSAVE**命令来生成RDB文件，这个过程会耗费主服务器大量的CPU、内存和磁盘I/O资源。
2. 主服务器需将生成的RDB文件发给从服务器，耗费大量网络资源。
3. 接收到RDB文件后，从服务器需载入RDB文件，造成阻塞而无法响应命令请求。

**3. 新版复制功能的实现**

Redis2.8以后使用**PSYNC**命令代替**SYNC**命令来执行复制时的同步操作，此命令具有**完整重同步**和**部分重同步**两种模式：

- **完整重同步**：用于处理初次复制情况，和**SYNC**命令执行步骤基本一样。
- **部分重同步**：当从服务器断线后重新连接主服务器时，主服务器可将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只需接受并执行这些命令就可和主服务器保持同步。

所以能看出区别来，执行**SYNC**命令需生成、传送和载入整个RDB文件，而部分重同步只需将从服务器缺少的写命令发送给从服务器执行就可以了。

**4. 部分重同步的实现**

部分重同步功能由以下三个部分构成：

- 主服务器的**复制偏移量**和从服务器的复制偏移量
- 主服务器的**复制积压缓冲区**
- 服务器的**运行ID**

**4.1 复制偏移量**

执行复制的双方——主服务器和从服务器会分别维护一个复制偏移量：

- 主服务器每次向从服务器发送N个字节数据时，其复制偏移量就加上N
- 从服务器每次从主服务器接收到N个字节数据时，其复制偏移量就加上N

通过主、从服务器的复制偏移量，程序很容易判断出两者的数据库状态是否一致，若两个偏移量相同则一致，否则不一致。

**4.2 复制积压缓冲区**

它是一个由主服务器维护的**固定长度、先进先出队列**，默认大小为1MB，可以根据需要和场景调整此缓冲区大小。

当主服务器进行命令传播时，他不仅会将写命令发送给所有从服务器，还会将**写命令**入队到复制积压缓冲区里。因此主服务器的复制积压缓冲区里会保存一部分最近传播的写命令，且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量。

| 偏移量 | 10087 | 10088 | 10089 | 10090 | 10091 | 10092 |
| ------ | ----- | ----- | ----- | ----- | ----- | ----- |
| 字节值 | '*'   | 3     | '\r'  | '\n'  | '$'   | 3     |

当从服务器重连上主服务器时，从服务器通过**PSYNC**命令将自己的复制偏移量offset发给主服务器，主服务器根据此复制偏移量来决定对从服务器执行何种同步操作：

- 若offset偏移量之后的数据仍存在于复制积压缓冲区里，则主服务器对从服务器执行部分重同步操作
- 相反offset偏移量之后的数据已不存在于复制积压缓冲区，那主服务器将对从服务器执行完整重同步操作（因为这是个固定长度队列，说明已经执行了很多命令，offset之后的有些命令已经不存在缓冲区里了，所以需要完整重同步）

**4.3 服务器运行ID**

这个字段的目的就是判断从服务器要重连的主服务器和上一次连接的是不是同一个。

- 每个Redis服务器不论主从都会有自己的运行ID
- 运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成。

当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传给从服务器，从服务器将这个运行ID保存起来。当从服务器断线并重连上一个主服务器时，会将之前保存的主服务器ID发送给它：

- 若两个此ID和现在的主服务器ID一致，则主服务器可尝试执行部分重同步操作。
- 否则主服务器将对从服务器执行完整重同步操作。

**5. PSYNC命令的实现**

此命令的调用方法有两种：

- 若从服务器以前未复制过任何主服务器或执行过**SLAVEOF** **no one**命令，则从服务器在开始一次新的复制时向主服务器发送PSYNC ？ -l命令，主动请求主服务器进行**完整重同步**。
- 相反从服务器已经复制过某个主服务器，则从服务器在开始一次新的复制时将向主服务器发送**PSYNC** **<runid> <offset>**命令：runid是上次复制的主服务器运行ID，offset是从服务器当前的偏移量，接受到这个命令的主服务器会根据这两个参数判断应执行哪种同步操作。

根据情况，主服务器接收到PSYNC命令后会返回以下三种之一：

- 若主服务器返回 +**FULLRESYNC** **<runid> <offset>**，表示主服务器要与从服务器执行完整重同步操作：其中runid是这个主服务器运行ID，从服务器会将它保存起来用于下一次发送PSYNC命令，而offset是主服务器当前的复制偏移量，从服务器将它作为自己的初始化偏移量。
- 若主服务器返回+ **CONTINUE**回复，则表示执行部分重同步操作，从服务器只需等着主服务器将自己缺少的那部分数据发送过来。
- 若主服务器返回 **-ERR**回复，表示主服务器版本低于Redis2.8，识别不了**PSYNC**命令，从服务器将会向主服务器发送**SYNC**命令，并执行完整同步操作。

**6. 复制的实现**

通过向主服务器发送SALVEOF命令，可以让一个从服务器去复制一个主服务器：

```
SALVEOF <master_ip> <master_port>
```

**6.1 步骤1：设置主服务器的地址和端口**

当客户端向从数据库发送下面**SALVEOF**命令

```
127.0.0.1:12345> SALVEOF 127.0.0.1 6379
```

从服务器首先要将客户端给定的**主服务器**IP地址127.0.0.1和端口6379保存到服务器状态的**masterhost**属性和**masterport**属性里。**SALVEOF**命令是一个**异步命令**，完成两个属性的设置后从服务器将向客户端返回OK表示复制指令已被接受，而实际复制工作是在OK返回后才开始执行。

**6.2 步骤2：建立套接字连接**

在**SLAVEOF**命令执行后，从服务器将根据命令所设置的IP地址和端口，创建连向主服务器的套接字连接。若连接成功，则从服务器将为这个套接字关联一个专门用于处理复制工作的**文件事件处理器**，它负责后续的复制工作，比如接受RDB文件、接收主服务器传播来的写命令等。

而主服务器接受从服务器的套接字连接后，将为该套接字创建相应的**客户端状态**。并将从服务器看做是一个连接到主服务器的客户端来对待。

**6.3 步骤3：发送PING命令**

从服务器成为主服务器客户端后，首先会向主服务器发送一个**PING**命令，它有两个作用：

- 虽然双方建立了套接字连接，但还未进行通信，通过发送**PING**命令可检查套接字的读写状态是否正常。
- 检查主服务器能否正常处理命令请求。

从服务器发送**PING**命令后会遇到下面三种情况之一：

- 若主服务器发送了命令回复，但从服务器不能在规定时间内读取回复内容，说明两者之间网络连接状态不好。此时从服务器要断开并重新创建连向主服务器的套接字
- 若主服务器返回一个错误，表示主服务器暂时无法处理这些请求，此时从服务器要断开并重新创建连向主服务器的套接字
- 若从服务器读取到“**PONG**”回复，表示主从服务器之间的网络连接状态正常，可继续复制工作。

**6.4 步骤4：身份验证**

从服务器收到主服务器返回的“PONG”回复后，下一步就是决定是否进行身份验证，它是通过从服务器的masterauth选项来决定。若从服务器设置了此选项，则会向主服务器发送**ATUTH masterauth**命令，验证阶段可能遇到的情况有以下几种：

- 若主服务器未设置requirepass选项，且从服务器也未设置，则主服务器执行从服务器发送的命令，复制工作可继续执行。
- 若从服务器通过**AUTH**命令发送的密码和主服务器requirepass选项设置的密码相同，则复制工作可继续；不相同，主服务器返回一个invalid password错误。
- 若主服务器设置了requirepass选项，从服务器却未设置masterauth选项，则主服务器返回一个NOAUTH错误；另一方面若主服务器未设置requirepass选项，而从服务器设置了masterauth选项，那么主服务器将返回一个no password is set错误。

所有错误情况都会令服务器中止目前的复制工作，并从创建套接字开始重新执行复制，直至身份验证通过，或从服务器放弃复制。

**6.5 步骤5：发送端口信息**

身份验证步骤后，从服务器将执行命令**REPLCONF listening-port <port-number>**，向主服务器发送从服务器的监听端口号。主服务器收到这个命令后，会将端口记录在从服务器对应的客户端状态的**slave_listening_port**属性中。**slave_listening_port**属性目前的唯一作用就是在主服务器执行INFO_replication命令时打印出服务器的端口号。

**6.6 步骤6：同步**

从服务器向主服务器发送**PSYNC**命令，执行同步操作，将自己的数据库状态更新至主数据库当前所处的状态。要注意在同步之前只有从服务器是主服务器的客户端，但在执行同步操作后，主服务器也会成为从服务器的客户端，因为执行两种的任一种同步操作都需要主服务器向从服务器发送写命令，完整——缓冲区、部分——复制积压缓冲区。

**6.7 步骤7：命令传播**

完成了同步后，主从服务器就会进入命令传播阶段。这是主服务器只要一直将自己执行的写命令发送给从服务器，而主服务器只要一直接受并执行主服务器发送的写命令，就可保证主从服务器一致。

**7. 心跳检测**

在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令：

**REPLCONF ACK <replication_offset>**

其中**replication_offset**是从服务器当前的复制偏移量。发送**REPLCONF ACK**命令对于主从服务器有三个作用：

- 检测主从服务器的网络连接状态
- 辅助实现min-slaves选项
- 检测命令丢失

**7.1 检测主从服务器连接状态**

主从服务器可通过发送和接受**REPLCONF ACK**命令来检查两者之间的网络连接是否正常：若主服务器超过一秒没有接收到从服务器发来的**REPLCONF ACK**命令，那么主服务器就知道主从服务器之间的连接出问题了。

可通过向主服务器发送**INFO replication**命令，查看lag一栏中所有从服务器最后一次向主服务器发送**REPLCONF ACK**命令距离现在过了多少秒。

**7.2 辅助实现min-slaves配置选项**

Redis的min-slaves-to-write和min-slaves-max-lag两个选项可防止主服务器在不安全的情况下执行写命令。例如我们向主服务器提供以下设置：

- min-slaves-to-write 3
- min-slaves-max-lag 10

那么在从服务器的数量少于3个或者3个从服务器的延迟（lag）都大于等于10秒时，主服务器将拒绝执行写命令。

**7.3 检测命令丢失**

若因网络故障，主服务器传播给从服务器的**写命令丢失**，那当从服务器向主服务器发送**REPLCONF ACK**命令时，主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器会根据从服务器发送的偏移量从自己的复制积压缓冲区里找到从服务器缺失的数据，并将这些数据重新发送给从服务器。

注意主服务器向从服务器补发缺失数据这一操作原理和部分重同步操作原理非常相似，区别在于：补发缺失数据操作发生在主从服务器**未断线**情况下，而部分重同步操作则是主从服务器**断线重连**后的操作。